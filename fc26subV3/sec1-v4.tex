
%!TEX root = mainMPOSv1.tex
\vspace{-.3cm}

\vspace{-.3cm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 1: Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:intro}
\vspace{-.3cm}

A recurring tension in blockchain design is to achieve high throughput and low latency without compromising security or decentralization. Traditional single-proposer (leader-based) protocols---from Bitcoin's longest chain to many proof-of-stake (PoS) variants---extend a single linear chain one block at a time. This serialization simplifies reasoning but forces a conservative block rate to preserve the \emph{common prefix} and \emph{chain quality} properties under network delay. If blocks are proposed faster than they propagate, honest views diverge, forks proliferate, and safety and liveness degrade. As a result, single-proposer designs deliberately throttle throughput, which prolongs confirmation latency.

Single-leader systems are also brittle under adverse conditions: even moderate asynchrony or partitions can trigger deep reorganizations, and a slow or malicious leader can temporarily suppress transactions, harming liveness and fairness. The upshot is a fundamental scalability--security trade-off: increasing throughput or tolerating higher latency in the network tends to weaken safety guarantees.

\vspace{-.3cm}

\subsection{From single-leader chains to multi-proposer DAGs}
% --- THIS PART IS NEW (trimmed 1.1) ---
Single-leader chains serialize block creation and concentrate forks on a single tip, making them sensitive to delay spikes and strategic withholding.
Multi-proposer DAGs distribute proposal opportunities across many validators and many tips, amortizing propagation delay and reducing the leverage of a temporary leader.
The remaining challenge is to retain chain-quality and finality without enforcing a total order at proposal time; our design addresses this with (i) window-bounded scoring and (ii) CCA-anchored conflict resolution.
% --- END NEW ---

\vspace{-.3cm}

\subsection{Our contributions}
\vspace{-.2cm}

% --- THIS PART IS NEW: make contributions scannable ---



We present \Proj, a family of stake-weighted, leaderless PoS protocols designed for low-latency finality and robustness under partial synchrony.
 %
As a running discipline, we require a short-reference window $w\ge\Delta$. % (formalized in \S~\ref{sec:param-discipline}).
 %
A central message of our analysis is that classical chain invariants do not directly lift to multi-proposer DAGs. We formalize DAG analogues of backbone properties---\emph{DAG Growth (DG)}, \emph{DAG Quality (DQ)}, and \emph{DAG Common Past (DCP)}---and show they must be paired with a fourth invariant, \emph{Tip Boundedness (TB)}, which caps the width of the honest frontier. Without TB, honest work can fragment indefinitely across many incomparable tips, preventing either safety or liveness even when DG/DQ/DCP hold.
\vspace{-.3cm}

\begin{itemize}
	\item \textbf{\ProjIdeal (idealized protocol).} We formalize a leaderless multi-proposer DAG protocol under synchrony and unbounded referencing, together with a CCA-anchored, window-filtered fork choice. We prove DG, DQ, DCP, TB, and derive persistence and liveness with confirmation depth $k = \Theta(w)$.
	\item \textbf{\ProjBase (practical protocol).} We realize the design under partial synchrony with VRF sortition, bounded short references (window $w$), and an optional weightless long reference for connectivity. We prove that under standard PoS assumptions (honest stake $H>1/2$) and $w \ge \Delta$, \ProjBase satisfies DG/DQ/DCP/TB and thus achieves persistence and liveness; withheld work outside the window does not help the adversary.
	\item \textbf{Backbone-style DAG invariants.} We adapt classical backbone arguments to a multi-proposer DAG by introducing DG/DQ/DCP and identifying \emph{Tip Boundedness} as a necessary invariant: DG/DQ/DCP alone do not imply ledger safety or liveness in a DAG.
	\item \textbf{Latency-friendly convergence.} The CCA-local, sliding-window fork choice aggregates honest references quickly and resists long-range withholding, enabling fast convergence once a windowed margin appears. This explains the observed low-latency finality in our simulations.
	\item \textbf{Evaluation.} Our simulator implements \ProjBase with an optimized adversary that withholds and releases DAG subtrees. Across a range of adversarial stakes and network delays, \Proj achieves consistently low reorg depths and fast stabilization, outperforming chain-based and earlier DAG-based baselines at comparable throughput.
\end{itemize}

\paragraph{Related work.} %
Our work builds on the Bitcoin backbone framework for chain protocols~\cite{EC:GarKiaLeo15} and its PoS variants (e.g., Snow White~\cite{FC:DaiPasShi19}, Ouroboros Praos/Genesis~\cite{EC:DGKR18,CCS:BGKRZ18}). Committee/BFT-style PoS protocols such as Algorand~\cite{Algorand}, HotStuff~\cite{HotStuff}, and Dfinity~\cite{Dfinity} achieve fast finality via explicit voting, at higher communication cost. Multi-proposer and DAG-based approaches include Spectre~\cite{EPRINT:MorKulYok18}, PRISM~\cite{Prism}, Tree-Graph~\cite{EPRINT:ZhaChaLeo18}, PHANTOM/GHOSTDAG~\cite{AFT:SWZ21}, Conflux (related line), and Avalanche~\cite{SnowFamily}; Narwhalâ€“Tusk~\cite{NarwhalTusk} decouples data availability from ordering within BFT. We differ in two ways: (i) our fork choice is explicitly \emph{CCA-anchored and window-filtered}, which neutralizes long-range withholding without auxiliary gadgets, and (ii) our security proof identifies and uses the quartet DG/DQ/DCP plus \emph{Tip Boundedness} as the right DAG analogue of chain backbone properties, showing TB is necessary for ledger safety and liveness under partial synchrony. Our analysis also connects to long-delay attacks in asynchronous settings~\cite{EC:PasSeeShe17}: the windowed, CCA-local rule together with TB serves as the DAG counterpart to the synchrony assumptions needed to preclude such attacks in chains. We further relate to unpredictability and eligibility design, and to economic and inclusion-list mechanisms orthogonal to our fork choice. 
Due to space limits, a  more elaborated version of the related work can be found in Appendix~\ref{sec:related}. 
