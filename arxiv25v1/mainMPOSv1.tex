%\documentclass[manuscript,nonacm,anonymous]{acmart}
%\documentclass[10pt]{article}
\documentclass[11pt]{article}
%\documentclass[10pt]{llncs}
%\documentclass[runningheads,a4paper]{llncs}

% Packages
\usepackage[english]{babel}
\usepackage[letterpaper,hmargin=1in,vmargin=1in]{geometry}
\usepackage{palatino}
\usepackage{xspace,xcolor,amsmath,mathtools,amssymb,amsfonts,amsthm}
\usepackage[svgnames,x11names,table]{xcolor}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float} % for [H] float spec
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subfig}
\usepackage{dsfont}
\usepackage[mathscr]{eucal}
\usepackage{hyperref}
\hypersetup{colorlinks=true,citecolor=blue,urlcolor=blue,bookmarks=false,hypertexnames=true}
\urlstyle{same}
\usepackage{array}
\usepackage{booktabs}
%\usepackage{tikz}
%\usetikzlibrary{arrows.meta,calc,positioning}

\usepackage{tikz}
\usetikzlibrary{arrows.meta,calc,positioning,decorations.pathreplacing}

%\lstset{escapeinside={(}{)}}

% Algorithmic keywords
\algrenewcommand\algorithmicrequire{\textbf{Input:}}
\algrenewcommand\algorithmicensure{\textbf{Output:}}

% Theorem environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{lemma}[theorem]{Lemma}

% Fonts and mathcal
\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}

\newcommand{\ignore}[1]{}
\newcommand{\hnote}[1]{{\color{DarkBlue}{\it [{\bf Hongsheng:} #1]}}}
\newcommand{\mnote}[1]{{\color{red}{\it [{\bf Marcin:} #1]}}}
\newcommand{\anote}[1]{{\color{DarkRed}{\it [{\bf Alvaro:} #1]}}}

% Project names
\newcommand{\Proj}{\ensuremath{\mathsf{Cryptareon}}\xspace}
\newcommand{\ProjZero}{\ensuremath{\mathsf{Cryptareon\text{-}Ideal}}\xspace}
\newcommand{\ProjIdeal}{\ensuremath{\mathsf{Cryptareon\text{-}Ideal}}\xspace}
\newcommand{\ProjOne}{\ensuremath{\mathsf{Cryptareon\text{-}Base}}\xspace}
\newcommand{\ProjBase}{\ensuremath{\mathsf{Cryptareon\text{-}Base}}\xspace}
\newcommand{\ProjTwo}{\ensuremath{\mathsf{Cryptareon\text{-}Full}}\xspace}
\newcommand{\ProjFull}{\ensuremath{\mathsf{Cryptareon\text{-}Full}}\xspace}
\newcommand{\ProjThree}{\ensuremath{\mathsf{Cryptareon\text{-}Private}}\xspace}
\newcommand{\ProjPrivate}{\ensuremath{\mathsf{Cryptareon\text{-}Private}}\xspace}

% Core symbols
\newcommand{\secp}{\ensuremath{\lambda}\xspace}
\newcommand{\negl}{\ensuremath{\mathsf{negl}}\xspace}

\newcommand{\state}{\ensuremath{\mathit{state}}\xspace}
\newcommand{\cZ}{\ensuremath{\mathscr{Z}}\xspace}
\newcommand{\cA}{\ensuremath{\mathscr{A}}\xspace}
\newcommand{\cP}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\exec}{\ensuremath{\mathsf{EXEC}}\xspace}
\newcommand{\chain}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\Chain}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\subchain}[2]{\ensuremath{\Chain_{#1}[{#2}]}\xspace}
\newcommand{\len}{\ensuremath{\mathsf{len}}\xspace}
\newcommand{\cut}{\ensuremath{\neg}\xspace}
\newcommand{\chainset}{\ensuremath{\mathds{C}}\xspace}
\newcommand{\View}{\ensuremath{\mathtt{VIEW}}\xspace}
\newcommand{\RR}{\ensuremath{\mathbb{R}}\xspace}
\newcommand{\NN}{\ensuremath{\mathbb{N}}\xspace}
\renewcommand{\P}{\ensuremath{\mathit{P}}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Global notation and macros (used by Sections 3 and 4)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sets and functions
\newcommand{\Val}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\Slot}{\ensuremath{\mathcal{S}}\xspace}
\newcommand{\Tx}{\ensuremath{\mathcal{T}}\xspace}
\newcommand{\Id}{\ensuremath{\mathcal{I}}\xspace}

% Keys, stake, and fractions
\newcommand{\pk}{\ensuremath{\mathrm{pk}}\xspace}
\newcommand{\sk}{\ensuremath{\mathrm{sk}}\xspace}
\newcommand{\stake}{\ensuremath{\mathrm{stake}}\xspace}
\newcommand{\StakeTot}{\ensuremath{\mathrm{Stake}{\mathrm{tot}}}\xspace}
\newcommand{\stakefrac}[1]{\ensuremath{\frac{\stake(#1)}{\StakeTot}}\xspace}

% Block accessors
\newcommand{\id}{\ensuremath{\mathrm{id}}\xspace}
\newcommand{\val}{\ensuremath{\mathrm{validator}}\xspace}
\newcommand{\slot}{\ensuremath{\mathrm{slot}}\xspace}
\newcommand{\txs}{\ensuremath{\mathrm{txs}}\xspace}
\newcommand{\tx}{\ensuremath{\mathtt{tx}}\xspace}
\newcommand{\refs}{\ensuremath{\mathrm{refs}}\xspace}
\newcommand{\shortrefs}{\ensuremath{\mathrm{refs}{\mathrm{in}}}\xspace}
\newcommand{\longrefs}{\ensuremath{\mathrm{refs}{\mathrm{out}}}\xspace}
\newcommand{\longref}{\ensuremath{\mathrm{longref}}\xspace}

% DAG reachability and closures
\newcommand{\Anc}{\ensuremath{\mathrm{Anc}}\xspace}
\newcommand{\Desc}{\ensuremath{\mathrm{Desc}}\xspace}

% Ledger and conflicts
\newcommand{\Valid}{\ensuremath{\mathrm{Valid}}\xspace}
\newcommand{\Conflicts}{\ensuremath{\mathrm{Conflicts}}\xspace}
\newcommand{\Inputs}{\ensuremath{\mathrm{Inputs}}\xspace}

% Tips and orders
\newcommand{\Tips}{\ensuremath{\mathrm{Tips}}\xspace}

% Procedures / primitives
\newcommand{\Eligibility}{\ensuremath{\textsc{Eligibility}}\xspace}
\newcommand{\VRFSign}{\ensuremath{\mathrm{VRFSign}}\xspace}
\newcommand{\VRFVerify}{\ensuremath{\mathrm{VRFVerify}}\xspace}
\newcommand{\VerifySig}{\ensuremath{\mathrm{VerifySig}}\xspace}
\newcommand{\Sign}{\ensuremath{\mathrm{Sign}}\xspace}
\newcommand{\Hash}{\ensuremath{\mathrm{Hash}}\xspace}

\newcommand{\domsep}{\ensuremath{\mathtt{Cryptareon}}\xspace}
\newcommand{\chainid}{\ensuremath{\mathrm{chainid}}\xspace}
\newcommand{\netid}{\ensuremath{\mathrm{netid}}\xspace}
\newcommand{\Encode}{\ensuremath{\mathrm{enc}}\xspace}

% Function-name macros used in pseudocode
\newcommand{\ExactMaxAntichain}{\textsc{ExactMaxAntichain}\xspace}
\newcommand{\GreedyAntichain}{\textsc{GreedyAntichain}\xspace}
\newcommand{\SampleMempool}{\textsc{SampleMempool}\xspace}
\newcommand{\OptionalLongRef}{\textsc{OptionalLongRef}\xspace}
\newcommand{\IntegrateAndGossip}{\textsc{IntegrateAndGossip}\xspace}
\newcommand{\AntichainSelection}{\textsc{AntichainSelection}\xspace}
\newcommand{\Broadcast}{\textsc{Broadcast}\xspace}

\newcommand{\ForkChoiceUpdate}{\textsc{ForkChoiceUpdate}\xspace}

% Fork-choice metrics
\newcommand{\wref}{\ensuremath{\mathrm{wref}}\xspace}
\newcommand{\BranchW}{\ensuremath{\mathrm{BranchW}}\xspace}
\newcommand{\CA}{\ensuremath{\mathrm{CA}}\xspace}
\newcommand{\CCA}{\ensuremath{\mathrm{CCA}}\xspace}
\newcommand{\contrib}{\ensuremath{\mathrm{contrib}}\xspace}

% Misc
\newcommand{\MCP}{\ensuremath{\mathrm{MCP}}\xspace}

\begin{document}

\title{
Cryptareon: Latency-Friendly Resilient Multi-Proposer Consensus
%\footnote{We refer interested readers to Álvaro Castro-Castilla’s ``New Cryptarchia,'' available at \url{https://www.notion.so/nomos-tech/New-Cryptarchia-202261aa09df8026b31ad5e09c1a3fbb}.}
\\
{\small {\sc Work in progress; Early draft}}
}
\author{
Álvaro Castro-Castilla\footnote{Institute of Free Technology. \ \ \texttt{alvaro@status.im}}
\and
Marcin Pawlowski\footnote{Institute of Free Technology. \ \ \texttt{marcin@status.im}}
\and
Hong-Sheng Zhou\footnote{Virginia Commonwealth University and Institute of Free Technology. \ \ \texttt{hszhou@vcu.edu}}
}

\maketitle





\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\pagestyle{plain}

\begin{abstract}
We present \Proj, a family of latency-friendly, stake-weighted, leaderless proof-of-stake consensus protocols. By allowing multiple proposers per slot and using a directed acyclic graph (DAG) structure, \Proj achieves high throughput and robustness. Blocks reference each other within a sliding window, forming maximal antichains that represent parallel “votes” on history. Conflicting branches are resolved via the closest common ancestor (CCA): each branch's weight (sum of recent references) is compared, and the heavier branch is chosen. This aggregation of honest work leads to rapid finality even under network delays and adversarial conditions. We define an idealized protocol (\ProjIdeal) that abstracts away delays and bounded references, and a practical variant (\ProjBase) that incorporates VRF-based eligibility, UTXO validity, and bounded references. We prove security in the partially synchronous model by formulating DAG analogs of common-prefix, chain-growth, and chain-quality properties. Our evaluation shows that \Proj achieves low latency and high finality rate with high adversarial stake, outperforming traditional chain-based and earlier DAG-based protocols.
\end{abstract}

\newpage
\small
\tableofcontents
\normalsize

\newpage
\pagenumbering{arabic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 1: Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:intro}

The evolution of blockchain consensus protocols has been shaped by an ongoing tension between scalability, security, and decentralization. Traditional chain-based protocols---such as Bitcoin and many proof-of-stake (PoS) variants---rely on a single proposer (leader) and extend a linear sequence of blocks. While this approach simplifies state replication, it inherently limits throughput and robustness. In particular, to ensure the {\em common prefix} property (that honest nodes' chains do not diverge beyond a certain point) and {\em chain quality} (that a sufficient fraction of blocks come from honest parties), chain-based protocols must keep the block production rate low relative to network latency. If blocks are produced too rapidly or if messages are delayed, honest nodes may fail to receive the latest block before creating the next one, leading to forks, orphaned blocks, and weakened security guarantees. This trade-off forces such protocols to suppress throughput, resulting in high confirmation latency and limited transaction capacity.

Moreover, the single-leader design makes chain-based systems vulnerable to network asynchrony and adversarial behavior. Adverse network conditions or message delays can break the common prefix, enabling chain reorganizations and double-spend attacks. Similarly, if a malicious or slow proposer controls a slot, it can censor or delay transactions, undermining liveness and fairness.

\subsection{Efficiency Bottlenecks in Chain-Based Consensus Protocols}
Chain-based consensus protocols, including Bitcoin~\cite{Bitcoin} and PoS variants like Ouroboros Praos~\cite{EC:DGKR18}, employ sequential block production: in each round or slot, a designated leader proposes a new block to extend the chain. This design simplifies certain proofs of safety, but introduces a fundamental scalability–security trade-off. The throughput must be throttled to ensure blocks propagate fully before the next one, or else forks become likely. If blocks are generated too quickly relative to network delay, honest nodes may see different chains, violating common-prefix, and undermining the security and liveness guarantees. Thus, to maintain safety, these protocols deliberately limit their block rate, resulting in higher latency and lower capacity.

Furthermore, when network conditions deteriorate (large delays or partitions), even these limited-throughput protocols can fail to maintain consistency. Single-proposer systems are particularly fragile: any disruption in message delivery can cause honest nodes to fall out of sync, allowing adversaries to execute chain reorganizations or double-spend attacks. In summary, traditional chain protocols face a bottleneck: increasing throughput or asynchrony directly threatens security, forcing a cautious pace.

\subsection{Multi-Proposer and DAG-Based Consensus}
To overcome these limitations, a new class of protocols has emerged that embraces {\em multi-proposer} (leaderless) designs and {\em directed acyclic graph} (DAG) data structures. In such protocols, multiple validators can propose blocks concurrently in each slot. Blocks reference each other (rather than a single predecessor), forming a DAG instead of a linear chain. This parallelism allows the system to utilize more of the available network bandwidth: all eligible validators can produce blocks in a slot, increasing throughput and resilience.

Each block typically cites as many recent blocks as possible (within a sliding window of time), creating a {\em maximal antichain}---a set of blocks that are mutually unreachable. These antichains represent independent “votes” on recent history, which all future blocks will reference and merge. Even if network delays cause temporary forks, the DAG structure allows honest work to accumulate in parallel branches and be resolved later.

\paragraph{Consensus via CCA and Stake Weighting:}
To decide on a single history, DAG-based protocols employ a fork-choice rule that aggregates votes (references) and uses stake weight. \Proj adopts the \emph{closest common ancestor} (CCA) rule to localize branch comparisons: given two conflicting heads, their fork merges at some CCA, and each branch's ``weight'' is measured from that point forward. Each block contributes weight (e.g., 1 or its creator's stake fraction) to the branch it extends. Honest validators always build on their current preferred branch, so over time the branch with more cumulative honest weight will dominate. The CCA rule ensures that an adversarial fork must compete \emph{locally} against the honest branch at each step, preventing deferred ``ambush'' tactics with withheld blocks. Combined with an \emph{anchored, window-limited} weight count (ignoring references older than $w$ slots), this yields rapid convergence: once one branch leads by a margin within the window, it stays ahead.

Importantly, multiple proposers per slot mean many honest blocks can extend different tips in parallel, but they will cite each other in the next round. This behavior resembles a voting committee whose size equals the number of online validators, without an explicit committee formation step. The DAG structure, with antichains of recent tips, naturally implements a form of one-step voting on conflicting histories: each new block implicitly votes for all the tips it references.

In effect, \Proj combines the advantages of backbone-style longest-chain protocols (simplicity and dynamic availability) with committee-based BFT (fast finality under good network conditions), all in a unified DAG framework. The design increases throughput and lowers latency while maintaining strong security guarantees, even under realistic network conditions.

\subsection{Our Contributions}
We introduce \Proj, a family of PoS consensus protocols that realize multi-proposer, DAG-based consensus with strong security and performance. Our key contributions include:

\begin{itemize}
\item {\bf \ProjIdeal (Idealized Protocol):} We define \ProjIdeal, an idealized version that abstracts away network delays, bounded references, and transaction dependencies. In this model, the network is synchronous, block references can span the entire DAG, and eligibility is public-coin. \ProjIdeal isolates the core consensus logic for analysis of safety and liveness. 
\item {\bf \ProjBase (Practical Protocol):} We present \ProjBase, a practical protocol that incorporates realistic constraints. Validators use a verifiable random function (VRF) for eligibility, transactions follow UTXO semantics, and each block's short references are restricted to a sliding window of recent slots. %We also include a slashing rule to discourage double-signing. 
\ProjBase's fork-choice uses a CCA-anchored, window-filtered weight metric.
\item {\bf Formal Security Analysis:} We formulate DAG-based analogues of the backbone properties (common prefix, chain growth, chain quality) suitable for multi-proposer DAGs. In particular, we define properties such as DAG growth, DAG quality, DAG common past. % and tip boundedness. 
Under standard PoS assumptions and partial synchrony, we prove that \ProjBase satisfies persistence (safety) and liveness of the ledger. Our proofs adapt coupling arguments from classical backbone analysis to the DAG setting.
\item {\bf Performance Evaluation:} We implement \ProjBase and evaluate it under varying adversarial stake and network delays. Our simulations demonstrate that \Proj achieves stable finality and high throughput, outperforming traditional chain-based protocols and earlier DAG-based designs (e.g., PHANTOM/GHOSTDAG, Avalanche~\cite{SnowFamily}, Lachesis). Notably, \Proj maintains consistency even with high adversarial stake and latency.
\item {\bf Relation to Prior Work:} We position \Proj in the context of existing consensus research. We draw connections to the Bitcoin/Ouroboros backbone framework~\cite{EC:GarKiaLeo15,EC:PasSeeShe17} and DAG-based protocols like PHANTOM~\cite{AFT:SWZ21} and Avalanche~\cite{SnowFamily}. We also compare to BFT protocols (Algorand~\cite{Algorand}, HotStuff~\cite{HotStuff}). Our key insight is that multi-proposer DAGs change the analysis: we combine elements of backbone arguments with new DAG properties. 
\end{itemize}

\section{Security Model}
\label{sec:model}

We adopt a standard cryptographic model for blockchain protocols~\cite{EC:GarKiaLeo15,EC:PasSeeShe17,JC:Canetti00}. The system comprises a set of validators $\cP$ and an environment $\cZ$ controlling inputs, timing, and corruptions. Time is divided into discrete slots $s=1,2,\ldots$. We assume a partially synchronous network~\cite{DLS88,EC:PasSeeShe17}: after some unknown Global Stabilization Time (GST), all honest messages are delivered within a known bound $\Delta$; before GST, the adversary controls delays. 

Players start from a common genesis block containing initial public keys and stake distribution. Validators may join or leave, and stake may change over time; for simplicity we consider a “flat” model where any player can register multiple identities to simulate more stake. The adversary $\cA$, controlled by $\cZ$, may adaptively corrupt validators up to a fraction $\alpha$ of total stake $\StakeTot=\sum_{v\in\cP}\stake(v)$. We assume $\alpha < 1/2$ unless otherwise specified. Upon corruption, $\cA$ learns the validator's secret key and internal state. Honest parties erase state upon leaving (non-persistent corruption).

The network is adversarial: the adversary $\cA$ controls message scheduling, reordering, and can delay honest messages (subject to the $\Delta$ bound after GST) but cannot modify or forge them. Any message broadcast by an honest party reaches all honest parties within at most $\Delta$ slots (after GST). 

\paragraph{VRF-based Eligibility.} Each validator $v$ holds a key pair $(\pk_v,\sk_v)$ and stake $\stake(v)$. In slot $s$, validator $v$ computes a VRF with domain separation:
\begin{equation*}
(y,\pi) = \VRFSign_{\sk_v}\bigl(\domsep \,\|\,\Encode(s)\bigr),
\end{equation*}
where $\domsep$ is protocol-specific constant, and $\Encode$ is a canonical encoding. We assume the VRF is secure: its output $y$ is unpredictable and unbiasable. Let $p(s,v)\in[0,1]$ be the per-slot threshold (e.g., $p(s,v) = \phi\cdot \stakefrac{v}$ for a global factor $\phi$ controlling expected parallelism). If $y < p(s,v)$, then $v$ is eligible to propose a block in slot $s$. In that case, $v$ produces a VRF proof $\pi$ with the block.

\paragraph{Block and DAG Structure.} When eligible, validator $v$ may create a block
\begin{equation*}
b = \langle \id(b),\slot(b),\val(b)=v,\txs(b),\refs(b),\longref(b),y(b),\pi(b),\sigma(b)\rangle,
\end{equation*}
where:
\begin{itemize}
  \item $\slot(b)=s$ is its slot and $\val(b)=v$ is the creator,
  \item $\txs(b)$ is a set of transactions (e.g., UTXOs) chosen from the mempool,
  \item $\refs(b)$ is a set of hashes of parent blocks, all within the recent window $[s-w+1,s]$ (“short references”),
  \item $\longref(b)$ is an optional single reference to an older block (outside the short window) for connectivity,
  \item $y(b)$ and $\pi(b)$ are the VRF output and proof, included in the block,
  \item $\sigma(b)$ is a signature on the block contents by the validator $v$.
\end{itemize}
The validator must ensure $\txs(b)$ is conflict-free (no double-spends) relative to the ledger state, and $\refs(b)\cup\{\longref(b)\}$ is an antichain in the DAG, to preserve consistency. Honest blocks are immediately gossiped to all nodes. The union of all blocks and reference edges forms a directed acyclic graph (DAG) $G$. We write $u\leadsto v$ if there is a directed path from block $u$ to $v$ in $G$. For a block $b$, let $\Anc(b)=\{a: a\leadsto b\}$ and $\Desc(b)=\{d: b\leadsto d\}$, with $\Anc^*(b)=\Anc(b)\cup\{b\}$, $\Desc^*(b)=\Desc(b)\cup\{b\}$. Two blocks $u$ and $v$ are {\em incomparable} (denoted $u\parallel v$) if neither $u\leadsto v$ nor $v\leadsto u$.

\paragraph{The Execution of Protocol.} The execution of the protocol is an interactive process: in each slot $s$, each honest player collects all messages (with adversarial delay $\le\Delta$), checks eligibility via VRF, possibly creates a block, and broadcasts it. The adversary may inject blocks for corrupted players and deliver or withhold messages. We denote by $\exec_{\Pi,\cA,\cZ}$ the complete execution transcript. Let $\chainset^s$ be the set of all chains (paths from genesis) visible to honest parties at slot $s$, and $\chain_i^s$ be the chain of party $i$ at slot $s$.

\subsection{Consensus Security Properties}
\label{sec:DG-DQ-DCP}

We recall the canonical properties for chain protocols~\cite{EC:GarKiaLeo15}: {\em Common Prefix (CP[$k$])} ensures any two honest chains differ only in the last $k$ blocks; {\em Chain Growth (CG[$\tau,\ell$])} guarantees any honest chain grows by at least $\tau\ell$ blocks over any $\ell$-slot window; and {\em Chain Quality (CQ[$\mu,\ell$])} ensures that in any $\ell$ consecutive blocks of an honest chain, at least a $\mu$ fraction are from honest parties. These imply persistence and liveness for classical blockchains~\cite{EC:GarKiaLeo15}.
For DAG-based protocols, we define analogous properties. 


\begin{figure}[htbp!]
\centering
\begin{tikzpicture}[x=1cm,y=0.8cm,>=Latex,thick]

  % Black = blocks
  \fill[black] (0,0) circle (2pt);
  \node[right=0.4cm of {(0,0)}] {\scriptsize Generic block};

  % Green = honest/finalized prefix
  \fill[green!40!black] (0,-1) rectangle (0.4,-0.6);
  \node[right=0.6cm of {(0.4,-0.8)}] {\scriptsize Honest/finalized prefix};

  % Blue = frontier
  \fill[blue!30] (0,-2) rectangle (0.4,-1.6);
  \node[right=0.6cm of {(0.4,-1.8)}] {\scriptsize Frontier / last $k_D$ layers};

  % Gray = common past
  \fill[black!20] (0,-3) rectangle (0.4,-2.6);
  \node[right=0.6cm of {(0.4,-2.8)}] {\scriptsize Common past region};

  % Red = transaction broadcast
  \fill[red!70] (0,-4) circle (2pt);
  \node[right=0.4cm of {(0,-4)}] {\scriptsize Transaction broadcast / inclusion};

\end{tikzpicture}
\caption{\textbf{Legend of colors used in Figures~\ref{fig:dg}--\ref{fig:liveness}.} 
Black = blocks; green = honest or finalized prefix; 
blue = frontier region; gray = common past; red = broadcast transaction event or inclusion.}
\label{fig:legend}
\end{figure}




\subsubsection{DAG Growth (DG)}
\label{sec:DG}

In any window of $\ell$ slots after GST, honest work makes \emph{linear progress along some honest chain} in the DAG: at least $\tau_D\cdot \ell$ honest blocks created in that window end up on the past of an honest party’s fork-choice tip (i.e., on its preferred branch).

\begin{figure}[htp!]
\centering
\begin{tikzpicture}[x=0.16cm,y=0.6cm,>=Latex,thick]
  % Axis
  \draw[-{Latex}] (0,0) -- (98,0) node[below right] {slots};

  % Interval [s, s+ell]
  \draw[very thick,|-|] (40,0) -- (80,0);
  \node[below] at (40,-0.1) {\scriptsize $s$};
  \node[below] at (80,-0.1) {\scriptsize $s+\ell$};
  \node[below] at (60,-0.2) {\scriptsize length $\ell$};

  % Honest blocks accumulating
  \foreach \x in {42,45,48,51,54,57,60,63,66,69,72,75,78} {
    \fill[black] (\x,0.8) circle (1.1pt);
  }
  \node[align=left] at (16,1.1) {\scriptsize Honest blocks created in $[s,s+\ell]$ \\[-1pt] \scriptsize join the past of some honest preferred tip};

  % Arrow up
  \draw[->] (60,0.6) -- (60,1.3);
  \node[above] at (60,1.3) {\scriptsize DG: $\ge \tau_D\ell$ honest on a preferred branch (w.h.p.)};
\end{tikzpicture}
\caption{\textbf{DAG Growth (DG).}
\small
Over any $\ell$-slot interval after GST, with probability $1-\negl(\lambda)$ at least $\tau_D\ell$ honest blocks become ancestors of \emph{an honest party’s fork-choice tip} (i.e., lie on some honest preferred branch). 
Black dots represent honest blocks produced during the interval.}

\label{fig:dg}
\end{figure}

\begin{definition}[DAG Growth]\label{def:DG}
Fix a security parameter $\lambda$ and let $\negl(\cdot)$ denote a negligible function.
Let $\mathrm{GST}$ be the global stabilization time and $\Delta$ the post-GST delay bound.
For any interval $I=[s,s+\ell-1]$ of $\ell$ consecutive slots with $s\ge \mathrm{GST}$, define $H_I$ to be the set of honest blocks created in $I$ that, by the end of slot $s+\ell-1+\Delta$, are contained in the ancestor set of the fork-choice tip of at least one honest party (equivalently, they lie on some honest party’s preferred branch).
We say $\mathrm{DG}[\tau_D,\ell]$ holds if for all such intervals
\[
\Pr\!\big[\,|H_I|\ \ge\ \tau_D\cdot \ell\,\big]\ \ge\ 1-\negl(\lambda).
\]
\end{definition}

\begin{remark}[Why this formulation]
In a leaderless multi-proposer DAG, many honest tips can coexist and grow in parallel.
Requiring linear growth of \emph{all} tips would conflate concurrency with lack of progress.
The DG we define here focuses on \emph{linear progress along some honest chain} (the past of an honest fork-choice tip), which is the DAG analogue of chain-growth in linear blockchains: despite parallelism, honest parties make steady ledger progress on a preferred branch.
This avoids interpreting DG as a global linearization of the whole DAG while still providing the liveness backbone needed for the safety/liveness proofs.
\end{remark}





\subsubsection{DAG Quality (DQ)} 
\label{sec:DQ}

In any window of $\ell$ slots, the fraction of honest blocks among all blocks entering the “recent frontier” (within the last $w$ slots on the preferred branch) is at least $\mu_D$.



\begin{definition}[DAG Quality]\label{def:DQ}
Fix a security parameter $\lambda$. For any interval $I=[s,s+\ell-1]$ with $s\ge \mathrm{GST}$, consider the set $B_I$ of blocks that enter the preferred branch's frontier (i.e., become descendants of the fork-choice tip) during $I$. Let $B_I^{\mathsf{H}}$ be those created by honest parties.
We say $\mathrm{DQ}[\mu_D,\ell]$ holds if
\begin{equation*}
\Pr\big[\,|B_I^{\mathsf{H}}|\ \ge\ \mu_D \cdot |B_I|\,\big]\ \ge\ 1-\negl(\lambda).
\end{equation*}
\end{definition}

\begin{figure}[htp!]
\centering
\begin{tikzpicture}[x=0.16cm,y=0.6cm,>=Latex,thick]
  % Axis
  \draw[-{Latex}] (0,0) -- (98,0) node[below right] {slots};

  % Frontier band over an interval
  \fill[blue!8] (40,1.4) rectangle (80,2.6);
  \draw[blue!60!black] (40,1.4) rectangle (80,2.6);
  \node[blue!60!black] at (60,2.9) {\scriptsize frontier over $[s,s+\ell]$};

  % Honest vs total markers in frontier
  \foreach \x in {42,46,50,54,58,62,66,70,74,78} {
    \fill[black] (\x,2.0) circle (1.1pt); % total
  }
  \foreach \x in {44,48,52,60,68,76} {
    \fill[green!50!black] (\x,2.0) circle (1.6pt); % honest subset
  }

  % Labels s and s+ell
  \draw[very thick,|-|] (40,0) -- (80,0);
  \node[below] at (40,-0.1) {\scriptsize $s$};
  \node[below] at (80,-0.1) {\scriptsize $s+\ell$};

  % Callout
  \node[align=center] at (60,0.9) {\scriptsize DQ: fraction of honest among frontier entrants $\ge \mu_D$ w.h.p.};
\end{tikzpicture}
\caption{\textbf{DAG Quality (DQ).} 
\small 
In any $\ell$-slot window after GST, the fraction of \emph{honest blocks} among those entering the advancing frontier is at least $\mu_D$ with probability $1-\negl(\lambda)$. 
In the illustration, the blue band marks the advancing frontier; 
black dots represent all blocks that enter this frontier, 
and green dots highlight the subset created by honest parties.}
\label{fig:dq}
\end{figure}





\subsubsection{DAG Common Past (DCP)}
\label{sec:DCP}

For any two honest views of the DAG at times $t_1\le t_2$, if we remove the last $k_D$ layers from the current frontier, the remaining past is identical. Equivalently, all honest parties share the set of ancestors up to the most recent CCA of their tips.

\begin{definition}[DAG Common Past (DCP)]\label{def:DCP}
Fix $k_D \in \mathbb{N}$. For an honest party $P$ at slot $t$, let $V_t^P$ denote
its view of the DAG at the end of $t$, and define
$\mathsf{Trim}(V_t^P,k_D)$ as $V_t^P$ with the last $k_D$ layers (by slots)
beneath its fork-choice tip removed.

We say $\mathrm{DCP}[k_D]$ holds if for all honest parties $P,Q$ and all slots
$t_1 \le t_2$ after $\mathrm{GST}$,
\[
\Pr\!\Big[\, \mathsf{Trim}(V_{t_1}^P,k_D)\;\subseteq\;\mathsf{Trim}(V_{t_2}^Q,k_D)\,\Big]
\;\ge\; 1-\negl(\lambda).
\]
That is, once the most recent $k_D$ layers are trimmed, the earlier view of
any honest party is always contained in the later view of any other honest party,
except with negligible probability.
\end{definition}



\begin{figure}[htbp!]
\centering
\begin{tikzpicture}[x=0.16cm,y=0.6cm,>=Latex,thick]
  % Axis
  \draw[-{Latex}] (0,0) -- (98,0) node[below right] {slots};

  % Common past region (identical after trimming)
  \fill[black!8] (0,1.4) rectangle (55,2.6);
  \draw (0,1.4) rectangle (55,2.6);
  \node at (27.5,2.0) {\scriptsize common past (identical)};

  % Frontier windows near t1 and t2 (last k_D layers)
  \fill[blue!8] (50,1.4) rectangle (65,2.6);
  \draw[blue!60!black] (50,1.4) rectangle (65,2.6);
%  \node[blue!60!black] at (62.5,2.95) {\scriptsize $\mathsf{Frontier}_{t_1}^P$};
  \node[blue!60!black] at (57.5,3.1) {\scriptsize $\mathsf{Frontier}_{t_1}^P$};

  \fill[blue!8] (80,1.4) rectangle (95,2.6);
  \draw[blue!60!black] (80,1.4) rectangle (95,2.6);
%  \node[blue!60!black] at (92.5,2.95) {\scriptsize $\mathsf{Frontier}_{t_2}^Q$};
  \node[blue!60!black] at (87.5,3.1) {\scriptsize $\mathsf{Frontier}_{t_2}^Q$};

  % Vertical markers t1, t2
  \draw[dashed] (65,0.3) -- (65,3.2) node[above] {$t_1$};
  \draw[dashed] (95,0.3) -- (95,3.2) node[above] {$t_2$};

  % Braces highlighting "trim" operation
  \draw[decorate,decoration={brace,amplitude=6pt}] (65,2.95) -- (50,2.95)
    node[midway,above=7pt] {\scriptsize remove last $k_D$};
  \draw[decorate,decoration={brace,amplitude=6pt}] (95,2.95) -- (80,2.95)
    node[midway,above=7pt] {\scriptsize remove last $k_D$};

  % Annotation showing subset relation of trimmed DAGs
  \node[align=center] (trimEq) at (40,0.55)
    {\scriptsize $\mathsf{Trim}(V_{t_1}^P,k_D)\;\subseteq\;\mathsf{Trim}(V_{t_2}^Q,k_D)$};

  % Arrows from braces to annotation
  \draw[->,blue!60!black] (57.5,2.65) .. controls (57.5,1.6) and (45,1.2) .. (trimEq.north);
  \draw[->,blue!60!black] (87.5,2.65) .. controls (87.5,1.6) and (55,1.2) .. (trimEq.north);

\end{tikzpicture}
\caption{\textbf{DAG Common Past (DCP).} 
The \textcolor{black!60!white}{gray region} shows the common past that all honest parties agree on. 
The \textcolor{blue!60!black}{blue regions} represent the most recent $k_D$ layers 
(\,$\mathsf{Frontier}_{t_1}^P$, $\mathsf{Frontier}_{t_2}^Q$\,) beneath the fork-choice tips at times $t_1\le t_2$. 
By removing these blue frontier layers, the earlier trimmed DAG is always contained in the later one,
i.e., $\mathsf{Trim}(V_{t_1}^P,k_D)\subseteq \mathsf{Trim}(V_{t_2}^Q,k_D)$,
with probability $1-\negl(\lambda)$.}
\label{fig:dcp}
\end{figure}


\begin{remark}[Consistency of DAG properties]
Definitions~\ref{def:DG} (DAG Growth),~\ref{def:DQ} (DAG Quality), and~\ref{def:DCP} (DAG Common Past) are all stated relative to an honest party’s fork-choice tip and its preferred branch. This ensures consistency across the properties: \emph{DG} guarantees linear progress on some honest preferred chain, \emph{DQ} guarantees that honest blocks dominate the frontier of that chain, and \emph{DCP} guarantees that honest parties’ preferred branches agree on a long common past. Together, these properties provide a coherent DAG analogue of the chain-growth, chain-quality, and common-prefix properties from backbone analyses.
\end{remark}



\newpage
\subsection{Ledger Security Properties}

\subsubsection{Persistence (Safety)}
A protocol has \emph{persistence} with parameter $k$ if for any two honest times $t_1\le t_2$,
the ledgers induced by the fork-choice at those times agree on all transactions that are at least $k$-deep at time $t_1$,
except with probability $\negl(\lambda)$.


\begin{figure}[htp!]
\centering
\begin{tikzpicture}[x=0.16cm,y=0.6cm,>=Latex,thick]
  % Axis
  \draw[-{Latex}] (0,0) -- (98,0) node[below right] {slots};

  % t1 and t2 markers
  \draw[dashed] (70,-2.0) -- (70,3.0) node[above] {$t_1$};
  \draw[dashed] (90,-2.0) -- (90,3.0) node[above] {$t_2$};

  % k-deep prefix at t1
  \fill[green!12] (0,1.4) rectangle (45,2.6);
  \draw[green!40!black] (0,1.4) rectangle (45,2.6);
  \node[green!40!black,anchor=west] at (0.5,2.0) {\scriptsize $k$-deep prefix at $t_1$};

  % Same prefix at t2 (visual echo)
  \draw[green!40!black,dashed] (0,1.4) rectangle (45,2.6);
  \node[green!40!black] at (22.5,1.0) {\scriptsize remains identical at $t_2$};

  % Legend arrow
  \draw[->] (46,2.0) -- (68,2.0) node[midway,above] {\scriptsize immutable region};
\end{tikzpicture}
\caption{\textbf{Persistence (Safety).} 
\small 
All but the last $k$ transactions in the ledger at time $t_1$ remain immutable and appear in every honest ledger at any later time $t_2\ge t_1$, except with probability $1-\negl(\lambda)$. 
The green region shows the $k$-deep finalized prefix at $t_1$, which remains unchanged in later ledgers.}

\label{fig:persistence}
\end{figure}

\begin{definition}[Persistence (Safety)]
Fix $k \in \mathbb{N}$. For an honest party $P$ and slot $t$, let $L_t^P$ denote
the ledger (totally ordered list of transactions) induced by applying the fork-choice
rule to $V_t^P$. We say $\mathrm{Persistence}[k]$ holds if for all pairs of honest
parties $P,Q$ and all slots $t_1 \le t_2$ after $\mathrm{GST}$,
\[
\Pr\!\Big[\, L_{t_1}^P[1..n-k] \;=\; L_{t_2}^Q[1..n-k] \,\Big] \;\ge\; 1-\negl(\lambda),
\]
where $n=|L_{t_1}^P|$. That is, all but the last $k$ transactions in $P$'s ledger
at time $t_1$ are immutable and appear in $Q$'s ledger at time $t_2$.
\end{definition}

\begin{remark}[On DAG Growth and Persistence]
The proof of persistence later in Sections~3.4.2 and~4.3.2 relies on DG 
to guarantee that honest blocks accumulate at a linear rate \emph{along honest preferred branches}. 
This ensures that once a block is $k$-deep under a fork-choice tip, the honest margin behind it 
grows steadily, preventing adversarial branches from overturning it. 
\end{remark}




\subsubsection{Liveness}



A protocol has \emph{liveness} with parameter $\ell_{\mathrm{live}}$ if for any valid transaction broadcast continuously by an honest party,
the transaction appears in the ledger of every honest party within $\ell_{\mathrm{live}}$ slots after $\mathrm{GST}$,
except with probability $\negl(\lambda)$.



\begin{figure}[htp!]
\centering
\begin{tikzpicture}[x=0.16cm,y=0.6cm,>=Latex,thick]
  % Axis
  \draw[-{Latex}] (0,0) -- (98,0) node[below right] {slots};

  % Broadcast start s and window [s, s+ell_live]
  \draw[very thick,|-|] (40,-0.8) -- (75,-0.8);
  \node[below] at (40,-0.8) {\scriptsize $s$};
  \node[below] at (75,-0.8) {\scriptsize $s+\ell_{\mathrm{live}}$};
  \node[below] at (57.5,-0.9) {\scriptsize inclusion window};

  % Broadcast event
  \fill[red!70] (40,-0.8) circle (1.3pt);
  \node[below=4pt,red!70] at (40,-0.8) {\scriptsize $\tx$ broadcast repeatedly};

  % Inclusion arrow into ledger
  \draw[->,red!70] (68,-0.3) -- (68,1.2);
  \node[red!70,align=center] at (68,1.5) {\scriptsize $\tx$ appears in $L_t^Q$\\[-1pt]\scriptsize for some $t\in[s,s+\ell_{\mathrm{live}}]$};
\end{tikzpicture}
\caption{\textbf{Liveness.} 
\small
Any valid transaction broadcast continuously by an honest party after GST is included in every honest ledger within $\ell_{\mathrm{live}}$ slots, except with probability $1-\negl(\lambda)$. 
Red marks the transaction broadcast event at slot $s$ and the inclusion window $[s,s+\ell_{\mathrm{live}}]$, with an arrow showing when the transaction enters an honest ledger.}

%\caption{\textbf{Liveness.} Any valid transaction broadcast continuously by an honest party after GST is included in every honest ledger within $\ell_{\mathrm{live}}$ slots, except with probability $1-\negl(\lambda)$.}
\label{fig:liveness}
\end{figure}


\begin{definition}[Liveness]
Fix $\ell_{\mathrm{live}} \in \mathbb{N}$. For any valid transaction $\tx$ that is
broadcast by an honest party $P$ in every slot after $\mathrm{GST}$, let
$E_t^Q(\tx)$ denote the event that honest party $Q$'s ledger $L_t^Q$ at the end of slot $t$
contains $\tx$. We say $\mathrm{Liveness}[\ell_{\mathrm{live}}]$ holds if for all honest parties $P,Q$
and for all slots $s \ge \mathrm{GST}$,
\[
\Pr\!\Big[\, \exists\, t \in [s,\,s+\ell_{\mathrm{live}}] : E_t^Q(\tx) \,\Big] \;\ge\; 1-\negl(\lambda).
\]
In words: any transaction repeatedly injected by an honest party after $\mathrm{GST}$
is guaranteed to appear in every honest party’s ledger within $\ell_{\mathrm{live}}$ slots,
except with negligible probability.
\end{definition}

\begin{remark}[On DAG Growth and Liveness]
Liveness requires that valid transactions eventually appear in all honest ledgers. 
The revised DG property, formulated with respect to preferred branches, 
ensures that honest block production makes linear progress in those branches. 
Coupled with TB (to prevent tips from fragmenting indefinitely) 
and DQ (to ensure honest dominance), this guarantees that transactions 
broadcast after GST will be absorbed and confirmed within bounded time. 
\end{remark}








\subsection{Tip Boundedness and Its Necessity}
\label{subsec:tip-boundedness}

The preceding properties (DAG Growth, DAG Quality, DAG Common Past) capture
progress, fairness, and eventual agreement on history. However, these three
alone are insufficient to guarantee a secure ledger. We introduce the additional
invariant of \emph{Tip Boundedness} (TB).

\begin{definition}[Tip Boundedness]
A protocol satisfies $\mathsf{TB}[\beta]$ if, at any time after GST, the number
of pairwise \emph{incomparable honest tips} (tips that are not ancestors of one
another) is at most $\beta$, except with negligible probability. Here $\beta$ is
$O(\Delta \cdot \text{block rate})$, i.e., proportional to the maximum number of
honest blocks that can be created during the delay window $\Delta$.
\end{definition}

\begin{remark}[Why this formulation]
Unlike DG, DQ, and DCP which can be interpreted in a linearized setting,
TB explicitly acknowledges the DAG’s concurrency: multiple tips may
exist at once. Bounding their number ensures that honest blocks regularly
\emph{merge or coalesce} tips, preventing indefinite fragmentation of honest
work. This makes DG, DQ, and DCP meaningful in the DAG setting, because they
now apply to a bounded set of preferred branches rather than an unbounded
frontier.
\end{remark}

\paragraph{Why TB Is Necessary.}
If the number of honest tips is unbounded, then:

\begin{itemize}
  \item \textbf{Safety problem:} Honest work fragments across many incomparable
  branches. In fork choice, an adversary can concentrate its weight on one branch
  to override the others. Even if DG, DQ, and DCP hold, safety fails because no
  branch accumulates a \emph{stable majority weight}. TB is necessary to limit
  the number of competing tips. By itself, TB does not guarantee that one branch
  immediately holds a majority (honest weight could still be split across a few
  tips), but it creates conditions under which honest cross-referencing and
  fork-choice dynamics ensure that one branch eventually dominates.
  \begin{remark}[Stable majority nuance]
  TB is thus a \emph{necessary but not sufficient} condition: it bounds
  fragmentation, and in combination with DG and DQ it yields eventual honest
  majority on one branch, assuming honest nodes cross-reference tips once visible.
  \end{remark}

  \item \textbf{Liveness problem:} Some honest blocks may remain stranded: if new
  tips appear faster than they can be merged, many honest transactions never
  receive enough descendants to be included in the common past. Liveness then
  fails, even though the DAG continues to grow.
  \begin{remark}[Transaction redundancy assumption]
  This liveness failure is most acute under the assumption that honest proposers
  do not re-include transactions once they have appeared in a block. If
  transactions from stranded blocks are eventually recycled into the mempool and
  included again, liveness of the \emph{transactions} can be salvaged, though at
  the cost of redundancy and wasted effort. We adopt the common assumption of
  no-transaction-redundancy to highlight why TB is critical.
  \end{remark}
\end{itemize}




\begin{lemma}[Necessity of TB for Ledger Properties]
DAG Growth, DAG Quality, and DAG Common Past are insufficient to imply persistence
and liveness of the ledger. In particular, without Tip Boundedness there exist
adversarial schedules where: (i) some honest blocks never accumulate any confirming
descendants (breaking liveness, under the no-redundancy assumption), and (ii) two
branches each accumulate enough honest blocks to satisfy DG, DQ, DCP, yet neither
dominates, allowing divergent ledgers (breaking safety).
\end{lemma}

\begin{proof}[Proof sketch]
Consider a DAG where honest proposers perpetually extend different tips (e.g., due
to adversarially scheduled network delays). Both branches keep growing linearly
(DG holds), each sees an honest fraction (DQ holds), and occasional cross-references
ensure a large common prefix (DCP holds). However, without TB, tips are never fully
merged: two branches may each gain infinitely many honest blocks without one ever
outweighing the other. One can construct a schedule where two honest groups alternate
extending two different tips, resulting in ``stalemated'' superchains. Honest
transactions included in one branch never appear in the ledger of parties following
the other branch (violating liveness, assuming no transaction redundancy), and a
block confirmed in one branch can later be overturned by the other branch’s growth
(violating persistence).
\end{proof}

\paragraph{Remark: TB vs.\ DCP and Relation to Long-Delay Attacks.}
DAG Common Past (DCP) does \emph{not} imply Tip Boundedness (TB). DCP ensures that if one trims away the most recent $k_D$ layers, then all honest views coincide on the older prefix. However, DCP does not constrain how many incomparable tips may exist within those last $k_D$ layers. In particular, one can have a DAG where the deep past is fully common (DCP holds), yet the active frontier contains $\Theta(\Delta \cdot \text{block rate})$ or even unboundedly many tips. Thus, persistence and liveness may fail even though DG, DQ, and DCP all hold: the honest work is fragmented across too many branches to form a stable margin.

This parallels the \emph{long-delay attack} described by Pass, Seeman, and shelat in their analysis of Nakamoto consensus in asynchronous networks \cite[Section~8]{EC:PasSeeShe17}. When network delays are large relative to block production, the honest chain fragments into many concurrent forks, which an adversary can exploit to cause deep reorgs. Our TB property directly precludes such fragmentation in DAG protocols: it enforces a bound on the width of the tip set, thereby ensuring that honest references continually \emph{merge or coalesce} the frontier. In this sense, TB is the DAG analogue of the synchrony assumption needed to rule out long-delay attacks in chain-based protocols.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse 






\begin{figure}[htp!]
\centering
\begin{tikzpicture}[x=0.55cm,y=0.9cm,>=Latex,thick]
  % =========================================================================
  % Styles
  \tikzstyle{honest}=[circle, fill=black, inner sep=1.2pt]
  \tikzstyle{adv}=[circle, fill=gray!60, inner sep=1.2pt]
  \tikzstyle{tipbox}=[rectangle, draw=black, rounded corners=2pt, fill=white, inner sep=2pt]
  \tikzstyle{crossref}=[dash pattern=on 2pt off 2pt, ->]
  \tikzstyle{flow}=[->, shorten >=1pt]

  % =========================================================================
  % PANEL (a): No TB — many incomparable tips accumulate
  % =========================================================================
  \begin{scope}[shift={(0,4.5)}]
    % Axis
    \draw[-{Latex}] (0,0) -- (23,0) node[below right] {\footnotesize time (slots)};
    % Title
    \node[anchor=west] at (0,3.2) {\footnotesize (a) \textbf{TB absent:} many incomparable tips accumulate};
    % Row labels
    \node at (-0.2,  2.2) {\scriptsize A};
    \node at (-0.2,  0.7) {\scriptsize B};
    \node at (-0.2, -0.8) {\scriptsize C};
    \node at (-0.2, -2.3) {\scriptsize D};

    % Shade recent k_D layers (for DCP trimming)
    \fill[blue!6] (15,-2.9) rectangle (22,2.9);
    \node[blue!60!black] at (18.5,3.05) {\scriptsize recent $k_D$ layers};

    % --- Four concurrent rows with occasional adversarial blocks ---
    % Row A (y=2)
    \foreach \i/\type in {1/honest,2/honest,3/adv,4/honest,5/honest,6/adv,7/honest,8/honest,9/honest,10/adv,11/honest,12/honest,13/honest,14/adv,15/honest,16/honest,17/adv,18/honest,19/honest,20/honest,21/adv,22/honest}{
      \node[\type] (A\i) at (\i,2) {};
    }
    \foreach \i in {1,...,21}{ \draw[flow] (A\i) -- (A\the\numexpr\i+1\relax); }

    % Row B (y=0.5)
    \foreach \i/\type in {1/adv,2/honest,3/honest,4/adv,5/honest,6/honest,7/adv,8/honest,9/honest,10/honest,11/adv,12/honest,13/honest,14/honest,15/adv,16/honest,17/honest,18/adv,19/honest,20/honest,21/honest,22/adv}{
      \node[\type] (B\i) at (\i,0.5) {};
    }
    \foreach \i in {1,...,21}{ \draw[flow] (B\i) -- (B\the\numexpr\i+1\relax); }

    % Row C (y=-1)
    \foreach \i/\type in {1/honest,2/adv,3/honest,4/honest,5/honest,6/adv,7/honest,8/adv,9/honest,10/honest,11/honest,12/adv,13/honest,14/honest,15/honest,16/adv,17/honest,18/honest,19/adv,20/honest,21/honest,22/honest}{
      \node[\type] (C\i) at (\i,-1) {};
    }
    \foreach \i in {1,...,21}{ \draw[flow] (C\i) -- (C\the\numexpr\i+1\relax); }

    % Row D (y=-2.5)
    \foreach \i/\type in {1/honest,2/honest,3/adv,4/honest,5/adv,6/honest,7/honest,8/honest,9/adv,10/honest,11/honest,12/honest,13/adv,14/honest,15/honest,16/honest,17/adv,18/honest,19/honest,20/honest,21/honest,22/adv}{
      \node[\type] (D\i) at (\i,-2.5) {};
    }
    \foreach \i in {1,...,21}{ \draw[flow] (D\i) -- (D\the\numexpr\i+1\relax); }

    % Cross-references to hint DCP
    \draw[crossref] (A4)  -- (B6);
    \draw[crossref] (B5)  -- (C7);
    \draw[crossref] (C9)  -- (D11);
    \draw[crossref] (D10) -- (A12);
    \draw[crossref] (A14) -- (C16);
    \draw[crossref] (B15) -- (D17);
    \draw[crossref] (C19) -- (A21);
    \draw[crossref] (D19) -- (B21);

    % Many tips (no TB): multiple tips near the end of each row
    \foreach \row/\y in {A/2,B/0.5,C/-1,D/-2.5} {
      \node[tipbox] at (22.2,\y+0.4) {\scriptsize tip};
      \draw[->] (22.2,\y+0.2) -- (\row22);
      \node[tipbox] at (20.7,\y+0.4) {\scriptsize tip};
      \draw[->] (20.7,\y+0.2) -- (\row21);
    }

    % Brace indicating unbounded width
%    \draw[decorate, decoration={brace, amplitude=5pt}] (16,3.0) -- (22,3.0)
    \draw[decorate, decoration={brace, amplitude=5pt}] (16,3.2) -- (22,3.2)
      node[midway, yshift=10pt] {\scriptsize many incomparable tips (unbounded)};

    % Annotations
%    \node[align=center] at (11, 1.7) {\scriptsize no bounded merge of tips \\[-1pt] \scriptsize (absence of TB)};
    \node[align=center] at (11, 1.3) {\scriptsize no bounded merge of tips \\[-1pt] \scriptsize (absence of TB)};
    \node[align=center] at (11,-1.8) {\scriptsize weight split across branches \\[-1pt] \scriptsize (no stable majority)};
  \end{scope}

  % =========================================================================
  % PANEL (b): With TB — frequent merging; bounded frontier (<= beta)
  % =========================================================================
  \begin{scope}[shift={(0,-4.0)}]
    % Axis
    \draw[-{Latex}] (0,0) -- (23,0) node[below right] {\footnotesize time (slots)};
    % Title
    \node[anchor=west] at (0,3.2) {\footnotesize (b) \textbf{TB present:} tips merge regularly; frontier width $\le \beta$};

    % Shade recent k_D layers (for DCP)
    \fill[blue!6] (15,-2.9) rectangle (22,2.9);
    \node[blue!60!black] at (18.5,3.05) {\scriptsize recent $k_D$ layers};

    % Build two rows (node names have no spaces: Ab<i>, Bb<i>)
    \foreach \i/\type in {1/honest,2/honest,3/adv,4/honest,5/honest,6/honest,7/honest,8/honest,9/honest,10/adv,11/honest,12/honest,13/honest,14/honest,15/honest,16/honest,17/honest,18/honest,19/honest,20/honest,21/adv,22/honest}{
      \node[\type] (Ab\i) at (\i,2)   {};
      \node[\type] (Bb\i) at (\i,-2)  {};
    }
    \foreach \i in {1,...,21}{
      \draw[flow] (Ab\i) -- (Ab\the\numexpr\i+1\relax);
      \draw[flow] (Bb\i) -- (Bb\the\numexpr\i+1\relax);
    }

    % Aggressive cross-references to merge tips (enforcing TB)
    \foreach \t in {4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21}{
      \draw[crossref] (Ab\t) -- (Bb\the\numexpr\t+1\relax);
      \draw[crossref] (Bb\t) -- (Ab\the\numexpr\t+1\relax);
    }

    % Few tips (bounded): only one tip per row near the end
    \node[tipbox] at (22.2,2.4) {\scriptsize tip};
    \draw[->] (22.2,2.2) -- (Ab22);
    \node[tipbox] at (22.2,-1.6) {\scriptsize tip};
    \draw[->] (22.2,-1.8) -- (Bb22);

    % Brace indicating bounded frontier
%    \draw[decorate, decoration={brace, amplitude=5pt}] (16,3.0) -- (22,3.0)
    \draw[decorate, decoration={brace, amplitude=5pt}] (16,3.2) -- (22,3.2)
      node[midway, yshift=10pt] {\scriptsize bounded frontier $\le \beta$};

    % Annotation
    \node[align=center] at (11,0.9) {\scriptsize frequent merging via cross-references \\[-1pt] \scriptsize $\Rightarrow$ stable majority (safety) \& inclusion (liveness)};
  \end{scope}

  % =========================================================================
  % Legend (shared)
  % =========================================================================
  \begin{scope}[shift={(0,-9.2)}]
    \node[honest] (lHon) at (1,0) {};
    \node at (2.6,0) {\scriptsize honest block};
    \node[adv] (lAdv) at (6,0) {};
    \node at (8.2,0) {\scriptsize adversarial block};
    \draw[crossref] (11,0) -- (12.7,0);
    \node at (14.7,0) {\scriptsize cross-reference};
    \fill[blue!6] (18.5,-0.35) rectangle (21,-0.05);
    \draw (18.5,-0.35) rectangle (21,-0.05);
    \node at (24.8,-0.2) {\scriptsize recent $k_D$ layers (DCP trim)};
  \end{scope}
\end{tikzpicture}

\caption{\textbf{Why Tip Boundedness (TB) is necessary.}
\small
\textbf{(a) TB absent.} DG and DQ can hold while the frontier widens: many incomparable tips persist
within the last $k_D$ layers (blue), splitting honest weight and making fork choice indecisive. This risks
both safety (no stable majority) and liveness (stranded honest transactions under no-redundancy).
\textbf{(b) TB present.} Regular cross-referencing merges tips, keeping the frontier width $\le \beta$.
Together with DG/DQ/DCP, a stable majority emerges and transactions confirm within bounded time.}
\label{fig:tb-necessity}
\end{figure}



\begin{remark}[Role of Tip Boundedness]
The properties DG, DQ, and DCP describe progress, 
honest dominance, and common past agreement along honest parties’ preferred branches. 
However, these three properties alone do not prevent fragmentation of honest work 
across many concurrent tips. 
Tip Boundedness (TB) complements them by enforcing a bound on the DAG’s width: 
it ensures that honest references continually merge tips so that the preferred branches 
identified by DG, DQ, and DCP do not diverge indefinitely. 
In this way, TB is the crucial invariant that bridges the DAG-specific concurrency 
with backbone-style ledger guarantees, enabling persistence and liveness.
\end{remark}


\subsection{From consensus properties to ledge properties} 
We now summarize how the DAG properties established above connect to the standard ledger
properties. DAG Growth (DG) ensures that honest blocks make linear progress on some preferred
branch; DAG Quality (DQ) guarantees that adversarial blocks cannot dominate the advancing
frontier; DAG Common Past (DCP) ensures that all honest parties agree on a long common
history once recent layers are trimmed; and Tip Boundedness (TB) limits concurrency so that
honest work is not fragmented across unbounded forks. Taken together, these four properties
yield the backbone properties of \emph{Persistence} (safety of confirmed transactions) and
\emph{Liveness} (eventual inclusion of valid transactions). Figure~\ref{fig:soundness-map}
illustrates this logical flow.

\begin{figure}[htp!]
\centering
\footnotesize
\begin{tikzpicture}[node distance=1.2cm, >=Latex, thick]

  % Styles
  \tikzstyle{inv}=[rectangle, rounded corners=3pt, draw=black, fill=blue!10, inner sep=4pt, minimum width=2.8cm, align=center]
  \tikzstyle{prop}=[rectangle, rounded corners=3pt, draw=black, fill=green!10, inner sep=4pt, minimum width=3cm, align=center]

  % properties nodes
  \node[inv] (dg) {DAG Growth (DG)};
  \node[inv, below=of dg] (dq) {DAG Quality (DQ)};
  \node[inv, below=of dq] (dcp) {DAG Common Past (DCP)};
  \node[inv, below=of dcp] (tb) {Tip Boundedness (TB)};

  % Ledger properties
  \node[prop, right=4.8cm of dq, yshift=0.7cm] (persist) {Persistence \\ (Safety)};
  \node[prop, right=4.8cm of dq, yshift=-1.7cm] (live) {Liveness};

  % Arrows
  \draw[->] (dg.east) -- ++(1.5,0) |- (persist.west);
  \draw[->] (dg.east) -- ++(1.5,0) |- (live.west);

  \draw[->] (dq.east) -- ++(1.5,0) |- (persist.west);
  \draw[->] (dq.east) -- ++(1.5,0) |- (live.west);

  \draw[->] (dcp.east) -- ++(1.5,0) |- (persist.west);

  \draw[->] (tb.east) -- ++(1.5,0) |- (persist.west);
  \draw[->] (tb.east) -- ++(1.5,0) |- (live.west);

\end{tikzpicture}
\caption{\textbf{Soundness map of DAG properties.}
\small
The four properties --- DAG Growth (DG), DAG Quality (DQ), DAG Common Past (DCP), and 
Tip Boundedness (TB) --- jointly imply ledger properties. 
DG and DQ provide progress and honest dominance, 
DCP ensures a long common past, 
and TB prevents unbounded fragmentation of tips. 
Together they yield Persistence (safety) and Liveness of the ledger.}
\label{fig:soundness-map}
\end{figure}

\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 3: Cryptareon-Ideal (NEW)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cryptareon-Ideal: Idealized Multi-Proposer Protocol}
\label{sec:ideal}
Having introduced the DAG properties (DG, DQ, DCP, TB) and their connection to ledger
properties in Section~\ref{sec:model}, we now turn to protocol design. The goal is to present an idealized
multi-proposer DAG protocol whose behavior can be analyzed directly against these properties.
By abstracting away practical constraints such as network delay, bounded references, and
transaction conflicts, the idealized model isolates the core consensus dynamics. This allows us
to prove that the protocol achieves DAG Growth, DAG Quality, DAG Common Past, and Tip
Boundedness, and therefore satisfies Persistence and Liveness. These proofs then serve as the
foundation for the more practical Cryptareon-Base protocol in Section~\ref{sec:base}.

\subsection{Overview}
\subsubsection{Assumptions}
\label{subsec:ideal-overview}
\ProjIdeal isolates the core consensus logic of a leaderless, multi-proposer DAG protocol to enable crisp arguments about safety and liveness. The model makes the following simplifying assumptions:
\begin{itemize}
  \item \textbf{Synchronous delivery:} time proceeds in slots; all honest messages broadcast in slot $s$ are delivered to all honest parties by the end of slot $s$ (zero-latency abstraction).
  \item \textbf{Public-coin eligibility:} each validator $v\in\Val$ independently becomes eligible in slot $s$ with probability $p\cdot\stakefrac{v}$ (a public-coin surrogate for VRF sortition).
  \item \textbf{Unbounded referencing:} when eligible, an honest block may reference \emph{any} existing block(s). Honest creators attempt to cite \emph{all} currently visible tips (equivalently, a maximum antichain).\footnote{Exact vs.\ greedy antichain selection is discussed; both are admissible in \ProjIdeal.}
  \item \textbf{Bounded fork-choice window:} \emph{weight} used in fork choice counts only references created within a fixed \emph{window} of most recent slots (window length $w\ge1$). This prevents long-range withholding from dominating fork choice (\S\ref{subsec:ideal-window-justification}).
  \item \textbf{No transaction conflicts:} to focus on consensus dynamics, we idealize away UTXO conflicts; each validator produces at most one block per slot by definition.
\end{itemize}


\subsubsection{Algorithms (for reference)}
We recall the algorithms already presented:
\begin{itemize}
  \item \textbf{Alg.~\ref{alg:ideal-antichain}} (\emph{AntichainSelection}): compute a (maximum or greedy) antichain of the current DAG.
  \item \textbf{Alg.~\ref{alg:ideal-create}} (\emph{Block Creation}): if eligible in slot $s$, build a block that references the selected antichain and broadcast it.
  \item \textbf{Alg.~\ref{alg:ideal-reception}} (\emph{Block Reception}): integrate a valid incoming block; update $\Tips$ and fork-choice state.
  \item \textbf{Alg.~\ref{alg:ideal-anchored-fc}} (\emph{Anchored Fork Choice}): score candidate tips by window-filtered reference weight anchored at $a$; pick the maximum.
  \item \textbf{Alg.~\ref{alg:ideal-cca}} (\emph{Conflict Resolution via CCA}): for conflicting heads $i,j$, anchor at $c=\CCA(i,j)$ and compare window-filtered branch weights; choose the heavier branch.
\end{itemize}

\subsubsection{Protocol Walkthrough (Honest Player View)}
\label{subsec:ideal-walkthrough}
This subsection explains how an \emph{honest} validator executes \ProjIdeal in each slot, and how fork choice and conflict resolution interplay with block creation and reception.

\paragraph{Per-slot loop (local state machine).}
At the beginning of slot $s$, an honest player $P$ has local DAG $G_s=(V_s,E_s)$:
\begin{enumerate}
  \item \textbf{Eligibility check.} $P$ samples public coins for slot $s$ and determines eligibility with probability $p\cdot\stakefrac{P}$.
  \item \textbf{Reference selection (Alg.~\ref{alg:ideal-antichain}).} $P$ deterministically computes an antichain $A_s\subseteq V_s$. In \ProjIdeal, $A_s$ may include \emph{all} current tips since referencing is unbounded.
  \item \textbf{Block creation (Alg.~\ref{alg:ideal-create}).} If eligible, $P$ constructs block $b_s=\langle \id,\val{=}P,\slot{=}s,\txs,\refs{=}A_s\rangle$ and broadcasts $b_s$.
  \item \textbf{Block reception and integration (Alg.~\ref{alg:ideal-reception}).} Throughout the slot and by its end, $P$ receives all blocks broadcast in slot $s$. For each block $b$ not yet in $V_s$, $P$ verifies well-formedness and acyclicity, inserts $b$ and edges $(r\to b)$ for all $r\in\refs(b)$, updates $\Tips(G)$ and incremental reachability summaries, and triggers \ForkChoiceUpdate.
  \item \textbf{Fork choice (Alg.~\ref{alg:ideal-anchored-fc}).} After integrating all blocks for slot $s$, $P$ runs anchored fork choice: for anchor $a$ (genesis or last finalized checkpoint), it computes window-filtered scores $W(T)$ for each $T\in\Tips(G)$ and sets the preferred tip $\hat{T}_s$ to the maximizer. The \emph{ledger view} of $P$ at the end of slot $s$ is the linearization induced by the preferred branch to $\hat{T}_s$.
  \item \textbf{Conflict resolution (Alg.~\ref{alg:ideal-cca}).} If two incomparable blocks $i,j$ imply conflicting ledger states above some ancestor, $P$ computes $c=\CCA(i,j)$ and compares window-filtered branch weights $\BranchW(i;c,w)$ vs.\ $\BranchW(j;c,w)$ to decide the winner. This rule is \emph{consistent} with the anchored fork choice: the preferred tip must lie on the heavier branch as measured from their CCA.
\end{enumerate}


%\newpage

\subsection{Protocol Details}

\subsubsection{Notation and Objects}
\label{subsec:ideal-notation}
We reuse the global notation from Section~\ref{sec:model}. Validators $\Val$ have stakes $\stake(v)>0$, total $\StakeTot=\sum_{v}\stake(v)$, share $\stakefrac{v} = \stake(v)/\StakeTot$. Slots $\Slot\subseteq\mathbb{N}$ are totally ordered. Transactions $\Tx$ exist but have no constraints. Block identifiers $\Id$ are totally ordered by, e.g., lexicographic hash order $\preceq_{\mathrm{id}}$; we then extend to a total order on blocks by $(\slot,\id)$ lexicographically. For blocks $u,v$, write $u \prec v$ if either $\slot(u)<\slot(v)$ or they share slot and $\id(u)\prec_{\mathrm{id}}\id(v)$.

A block is $b=\langle \id(b),\,\val(b),\,\slot(b),\,\txs(b),\,\refs(b)\rangle$. Here $\val(b)\in\Val$ and $\slot(b)\in\Slot$ denote its creator and slot; $\txs(b)\subseteq\Tx$ are its transactions; and $\refs(b)\subseteq\Id$ is a set of parent block identifiers (an antichain by construction). The reference-DAG is $G=(V,E)$ where $V$ is the set of all blocks, and $(r\to b)\in E$ iff $r\in \refs(b)$. We require $G$ to be acyclic. We write $x\leadsto y$ if there is a directed path from block $x$ to $y$. Define:
\begin{equation*}
\Anc(b)=\{a\in V: a\leadsto b\},\quad \Anc^*(b)=\Anc(b)\cup\{b\},
\end{equation*}
and 
\begin{equation*}
\Desc(b)=\{d\in V: b\leadsto d\},\quad \Desc^*(b)=\Desc(b)\cup\{b\}.
\end{equation*}
Blocks $u,v$ are incomparable, written $u\parallel v$, if neither $u\leadsto v$ nor $v\leadsto u$.

\paragraph{Public-Coin Eligibility.} Fix a probability $p\in(0,1]$. In each slot $s$ and for each $v\in\Val$, we independently let $\Pr[\Eligibility(v,s)=1] = p\cdot \stakefrac{v}$. (This simulates the VRF threshold.) If $\Eligibility(v,s)=1$, validator $v$ creates a block.

\paragraph{Tips.} The tip set $\Tips(G)$ of the DAG $G$ is the set of vertices with no descendants: $\Tips(G)=\{v\in V:\ \nexists\,u\in V \text{ with } v\to u\}$. More formally, 

\begin{definition}[Tips]
For a DAG $G=(V,E)$, $\Tips(G)\triangleq\{v\in V:\text{$v$ has out-degree $0$}\}$.
\end{definition}

\subsubsection*{Additional Definitions Used in this Section}

\begin{definition}[Antichain; Maximal vs Maximum]
$A\subseteq V$ is an antichain if all elements are pairwise incomparable in $G$. Maximal means inclusion-maximal; maximum means largest cardinality.
\end{definition}
\begin{definition}[\GreedyAntichain\ on $G_{s,w}$]
Fix total order $\prec$ on vertices by $(\slot,\id)$. Scan vertices of $G_{s,w}$ in decreasing $\prec$, adding $v$ if $v$ is incomparable with all current elements; output is a \emph{maximal} antichain. All honest nodes use the same $\prec$; hence determinism.
\end{definition}
\begin{definition}[\OptionalLongRef]
Given current slot $s$ and window $w$, optionally choose a single $\ell\notin G_{s,w}$ for connectivity: prefer the last finalized checkpoint if known; otherwise the $\prec$-max ancestor of $\min_{\prec}R$ with $\slot(\ell)\le s-w$. Long-refs never contribute to weight.
\end{definition}
\begin{definition}[\SampleMempool]
Let $N_{\MCP}$ be the target number of parallel proposers per slot. Given seed $\rho$, include transaction $x$ iff 
$H(\rho\|\mathrm{txid}(x))<\tfrac{1}{N_{\MCP}}\cdot 2^\kappa$, then filter to a maximal conflict-free subset.
\end{definition}
\begin{definition}[Closures on Sets]
For $H\subseteq V$, $\Anc^*(H)\triangleq \bigcup_{h\in H}\Anc^*(h)$ and similarly for $\Desc^*(H)$.
\end{definition}
\begin{definition}[Conflict Predicate \Conflicts]
Let $\Inputs(x)$ be the set of consumed UTXOs of transaction $x$. A set $T$ is conflict-free with respect to $H$ if (i) $\{\Inputs(x):x\in T\}$ are pairwise disjoint,
(ii) $\Inputs(T)$ is disjoint from $\Inputs(\txs(\Anc^*(H)))$, and (iii) each $x\in T$ passes $\Valid(S,x)$, where $S$ is the state induced by $\Anc^*(H)$. Define $\Conflicts(T,H)$ to be true if $T$ is \emph{not} conflict-free w.r.t.\ $H$.
\end{definition}
\begin{definition}[Contribution Function $\contrib$]
Let $\theta\in\{\mathsf{equal},\mathsf{stake}\}$ be a protocol parameter. Define $\contrib(d)=1$ if $\theta=\mathsf{equal}$ and $\contrib(d)=\stakefrac{\val(d)}$ if $\theta=\mathsf{stake}$.
\end{definition}
\begin{definition}[\ForkChoiceUpdate]
Maintain a cache comprising $\Tips(G)$, a per-validator latest-block map $L:\Val\to V\cup\{\bot\}$, and window reachability summaries sufficient to evaluate antichain tests and window-weight sums.
\end{definition}
\begin{definition}[\Broadcast]
We assume authenticated broadcast: any message sent by an honest party is delivered to every honest party within $\Delta$ slots after GST.
\end{definition}
\begin{definition}[Anchor Selection for Fork-Choice]
Let $a$ be the last finalized checkpoint if one exists; otherwise the earliest block whose slot $\le s-w$ on the preferred branch, else genesis.
\end{definition}

\subsubsection{Idealized Antichain Selection and Block Creation}
In \ProjIdeal, when a validator $v$ is eligible at slot $s$, it samples transactions and references all current tips (or equivalently, all blocks in a maximum antichain). The following algorithm captures this:

\begin{algorithm}[H]
\caption{\AntichainSelection (Idealized)}
\label{alg:ideal-antichain}
\begin{algorithmic}[1]
\Require Global DAG $G=(V,E)$
\Ensure Antichain $A\subseteq V$
\State $A \gets \ExactMaxAntichain(G)$ \Comment{or use \GreedyAntichain deterministically}
\State \Return $A$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Block Creation (Idealized, per validator $v$ at slot $s$)}
\label{alg:ideal-create}
\begin{algorithmic}[1]
\Require Global DAG $G=(V,E)$, validator $v$, slot $s$
\If{$\Eligibility(v,s)=1$}
  \State $T \gets \SampleMempool()$ \Comment{Sample transactions (no conflicts assumed)}
  \State $A \gets \AntichainSelection(G)$
  \State $b \gets \langle \id,\,\val=v,\,\slot=s,\,\txs=T,\,\refs=A\rangle$
  \State Insert $b$ and edges $(r\to b)$ for $r\in A$ into $G$
  \State \Broadcast($b$) \Comment{Broadcast block}
\EndIf
\end{algorithmic}
\end{algorithm}

\subsubsection{Idealized Block Reception}
\begin{algorithm}[H]
\caption{Block Reception (Idealized)}
\label{alg:ideal-reception}
\begin{algorithmic}[1]
\Require Incoming block $b$, reference-DAG $G=(V,E)$
\Ensure $b$ is accepted into $G$ or deferred/rejected
\If{$b\in V$} \Return \EndIf
\If{$\exists r\in \refs(b)$ such that $r\notin V$}
  \State Request missing parents $r$; enqueue $b$; \Return
\EndIf
\If{$\exists r\in \refs(b)$ such that $r \in \Desc^*(b)$} \textbf{reject} $b$ \EndIf
\State Insert $b$ into $G$: add vertex and edges $(r\to b)$ for $r\in\refs(b)$
\State Update $\Tips(G)$ and reachability summaries
\State \ForkChoiceUpdate($G$) \Comment{Update fork-choice state}
\State \Broadcast($b$)
\end{algorithmic}
\end{algorithm}

\subsubsection{Fork Choice (Idealized)}
We use a CCA-anchored, window-filtered weight metric. Fix a window parameter $w\ge1$. For any block $d$, define
\begin{equation*}
\wref(d;w) \;=\; \bigl|\{r\in \refs(d):\,\slot(d)-\slot(r) < w\}\bigr|
\end{equation*}
(the number of references within $w$ slots). 

\paragraph{Anchored Fork Choice.} Given an anchor block $a$ (e.g., genesis) and a tip $T$, define its score
\begin{equation*}
W(T)\;=\;\sum_{\substack{d\in\Desc^*(T)\\a\leadsto d}} \wref(d;w).
\end{equation*}
We select the tip $\hat{T}$ with maximum score (breaking ties by the deterministic order $\prec$):

\begin{algorithm}[H]
\caption{Anchored Fork Choice (Idealized)}
\label{alg:ideal-anchored-fc}
\begin{algorithmic}[1]
\Require Anchor $a\in V$, candidate tips $\mathcal{T}\subseteq \Tips(G)$, window $w$
\Ensure Selected tip $\hat{T}$
\State $\hat{T}\gets \bot, \hat{W}\gets -\infty$
\ForAll{$T \in \mathcal{T}$}
  \State $W(T)\gets\sum_{\substack{d\in\Desc^*(T)\\a\leadsto d}} \wref(d;w)$
  \If{$W(T)>\hat{W}$ \textbf{or} ($W(T)=\hat{W}$ and $T\prec \hat{T}$)}
    \State $\hat{T}\gets T,\ \hat{W}\gets W(T)$
  \EndIf
\EndFor
\State \Return $\hat{T}$
\end{algorithmic}
\end{algorithm}

\paragraph{Conflict Resolution via CCA.} For two conflicting blocks $i$ and $j$, let 
\begin{equation*}
\CA(i,j)=\Anc^*(i)\cap \Anc^*(j),\qquad
\CCA(i,j)=\arg\max_{c\in \CA(i,j)}(\slot(c),\id(c))
\end{equation*}
with ties broken by $\id$. Let $c=\CCA(i,j)$. Define the branch weight from $c$:
\begin{equation*}
\BranchW(x; c, w) = \sum_{\substack{d\in V:\\ x\leadsto d,\ c\leadsto d}} \wref(d;w),\quad x\in\{i,j\}.
\end{equation*}
We choose the branch head $h^*\in\{i,j\}$ with larger weight:

\begin{algorithm}[H]
\caption{Conflict Resolution (Idealized)}
\label{alg:ideal-cca}
\begin{algorithmic}[1]
\Require Conflicting blocks $i,j$, window $w$
\Ensure Winning block $h^*$
\State $c \gets \CCA(i,j)$
\State $W_i\gets\BranchW(i;c,w)$, \quad $W_j\gets\BranchW(j;c,w)$
\If{$W_i > W_j$} \Return $i$
\ElsIf{$W_j > W_i$} \Return $j$
\Else \Return $\min\nolimits_{\prec}\{i,j\}$ \Comment{deterministic tie-break}
\EndIf
\end{algorithmic}
\end{algorithm}


%\newpage

\paragraph{Finalization rule (informal).}
In \ProjIdeal, blocks become \emph{finalized} purely through the fork-choice dynamics,
without requiring any separate BFT-style gadget.
Specifically, an honest party may treat a block as final once it is
$k$-deep under the current preferred tip, for a parameter
$k=k(w,\epsilon)$ established in the safety analysis
(\S\ref{subsec:ideal-ledger-props}).
Intuitively, once a block has accumulated sufficient window-filtered weight,
any conflicting branch beyond the relevant CCA cannot overtake it,
since adversarial work created outside the last $w$ slots has no effect.

\begin{remark}[Comparison with BFT-style finality]
Traditional BFT-based protocols (e.g., HotStuff, Casper FFG) achieve finality
through explicit voting and quorum certificates.
In contrast, our design provides \emph{probabilistic finality} directly from
the weight-based fork-choice and bounded-window analysis:
a block becomes irreversible once its depth ensures an honest margin
that no adversary with $\alpha < 1/2$ stake can overcome.
Thus, finality emerges organically from the ledger’s growth properties,
without any auxiliary consensus layer.
\end{remark}

\subsection{On Unbounded Referencing vs.\ Bounded Fork Choice}
\label{subsec:ideal-window-justification}
\ProjIdeal allows \emph{unbounded referencing}: an honest block may cite \emph{all} existing tips (or a maximum antichain), which accelerates convergence and directly implies Tip Boundedness (TB) in the synchronous ideal.
However, using \emph{unbounded} weight in fork choice (i.e., counting all references since genesis) is unsafe even in a synchronous model because an adversary can \emph{withhold} a private subtree for many slots and then reveal it at once. The revealed descendants would contribute large cumulative score to an adversarial branch, potentially overriding the honest branch despite minority stake.

\begin{lemma}[Unsafe infinite-horizon weight]
Even under synchrony and honest majority, if fork choice scores branches by \emph{unbounded} descendant counts since genesis, there exists a withholding strategy that can cause arbitrarily deep reversions with non-negligible probability.
\end{lemma}

\begin{proof}[Proof sketch]
Let the adversary with stake fraction $\alpha<1/2$ privately build a subtree extending from a recent CCA while the honest parties continue extending the public branch. After $L$ slots, the private subtree accumulates $\Theta(\alpha L)$ references while the honest branch accumulates $\Theta((1-\alpha)L)$. If the scoring aggregates from genesis, the adversary can time its release to coincide with honest fragmentation at the frontier (many tips), so the adversarial branch appears heavier due to concentrated weight. Since contributions are not window-limited, the \emph{entire} private accumulation applies, enabling deep reorgs. Window-filtering neutralizes this leverage by discarding stale contributions outside the last $w$ slots.
\end{proof}

\noindent\textbf{Conclusion.} In \ProjIdeal we \emph{retain unbounded referencing} (for rapid merging and TB), but we \emph{require a bounded window $w$ in the fork-choice metric}. This pairing preserves fast convergence while preventing long-range weight accumulation from withheld blocks.

\subsection{Security of the Idealized Protocol}
\label{subsec:ideal-security}
We now prove that \ProjIdeal satisfies the DAG properties (DG, DQ, DCP, TB) and, consequently, \emph{ledger persistence (safety)} and \emph{liveness}. Throughout, let the honest stake fraction be $H\in(1/2,1]$ and let $p\in(0,1]$ be the per-slot eligibility rate (public-coin). All statements hold \emph{except with negligible probability} in the security parameter $\lambda$ (via Chernoff-type bounds).


\subsubsection{Consensus Properties}

\paragraph{Preliminaries.} In slot $s$, the number of honest eligible validators is $\mathrm{Hon}_s\sim \mathrm{Binomial}(|\Val|,\,p\cdot \mathbb{E}[\stakefrac{v}\,|\,v\text{ honest}])$, with expectation $\Theta(pH|\Val|)$. Under synchrony and unbounded referencing, all blocks created in slot $s$ can reference \emph{all tips visible at the start of the slot}, and all honest parties receive the same set of blocks by the end of the slot.

\begin{theorem}[DAG Growth (DG) in \ProjIdeal]
\label{thm:ideal-DG}
Fix any interval of $\ell$ slots after GST. With probability $1-\negl(\lambda)$, at least $\tau_D\ell$ honest blocks are created and become ancestors of some honest tip by the end of the interval, for $\tau_D=\Theta(pH)$.
\end{theorem}
\begin{proof}[Proof sketch]
Linearity and Chernoff concentration on $\sum_{s} \mathrm{Hon}_s$ give $\Theta(pH\ell)$ honest blocks in the interval. Under synchrony, each of these blocks is referenced by subsequent honest blocks in the next slot, hence becomes an ancestor of an honest tip. 
\end{proof}

\begin{theorem}[DAG Quality (DQ) in \ProjIdeal]
\label{thm:ideal-DQ}
For any $\ell$-slot window after GST, the fraction of honest blocks entering the preferred frontier is at least $\mu_D=\Theta(H)$ with probability $1-\negl(\lambda)$.
\end{theorem}
\begin{proof}[Proof sketch]
Eligibility is stake-proportional and independent across validators; thus the expected honest fraction per slot is $H$. Since fork-choice is deterministic and anchored, the selection process does not bias adversarial blocks upwards; Chernoff bounds imply concentration around $H$ over $\ell$ slots.
\end{proof}

\begin{theorem}[Tip Boundedness (TB) in \ProjIdeal]
\label{thm:ideal-TB}
With unbounded referencing and synchrony, $\mathrm{TB}[\beta]$ holds with $\beta=O(p\,|\Val|)$.
\end{theorem}
\begin{proof}[Proof sketch]
At most $O(p\,|\Val|)$ honest blocks are created in a slot; each of them references \emph{all} pre-existing tips, so all prior tips are buried and removed from $\Tips(G)$. Thus the tip set after each slot is bounded by the number of new blocks created in that slot.
\end{proof}

\begin{theorem}[DAG Common Past (DCP) in \ProjIdeal]
\label{thm:ideal-DCP}
There exists $k_D=O(1)$ such that removing the last $k_D$ layers beneath each honest party's preferred tip yields identical ancestor sets, with probability $1-\negl(\lambda)$.
\end{theorem}
\begin{proof}[Proof sketch]
Synchrony implies identical views at the end of each slot. By TB, the frontier width is $O(1)$ (in expectation and with exponential tails). Because honest blocks in slot $s{+}1$ reference all tips from slot $s$, any divergence confined to the last $O(1)$ layers is reconciled in one step. Hence $k_D=O(1)$ suffices.
\end{proof}

\subsubsection{Ledger Properties (Persistence and Liveness)}
\label{subsec:ideal-ledger-props}
We now show that \ProjIdeal's anchored, window-filtered fork choice, coupled with CCA-based conflict resolution, yields ledger safety and liveness.

\begin{theorem}[Persistence (Safety) of \ProjIdeal]
\label{thm:ideal-safety}
There exists $k=k(w,\epsilon)$ such that if a block $B$ is $k$-deep under the preferred tip of an honest party at the end of some slot, then with probability $1-\negl(\lambda)$, $B$ remains in the ledger of all honest parties at all future times (no conflicting ledger can supersede it).
\end{theorem}
\begin{proof}[Proof sketch]
Consider any conflicting branch revealed later whose head $j$ competes against the honest head $i$ after their CCA $c=\CCA(i,j)$. By DG, DQ, and TB, the honest branch accumulates $\Omega(w)$ window-filtered references in the next $w$ slots. Since fork choice counts only the last $w$ slots anchored at $c$, any adversarial references created \emph{more than $w$ slots} ago (e.g., withheld) contribute zero score. Thus, once the honest branch leads by a margin growing with $w$, the adversary cannot overturn it without controlling $\ge 1/2$ of stake \emph{within the window}. Choosing $k=\Theta(w)$ ensures this margin has formed \emph{before} $B$ is declared final, yielding persistence.
\end{proof}

\begin{theorem}[Liveness of \ProjIdeal]
\label{thm:ideal-liveness}
For any valid transaction $\tx$ broadcast by an honest party after GST, there exists $\ell_{\mathrm{live}}=\mathrm{poly}(1/p,1/H)$ such that $\tx$ appears in the ledger of every honest party within $\ell_{\mathrm{live}}$ slots, except with negligible probability.
\end{theorem}
\begin{proof}[Proof sketch]
In each slot, with constant probability at least one honest validator is eligible; upon eligibility, the validator can include $\tx$. Under synchrony and unbounded referencing, subsequent honest blocks reference the block containing $\tx$ and quickly bury it. Using DG, DQ, and TB, the block's descendant count grows linearly over time, and the window-filtered fork choice maintains the branch as preferred, so $\tx$ enters all honest ledgers within $O(\log(1/\negl))$ slots; optimizing constants yields $\ell_{\mathrm{live}}=\tilde{O}(1/(pH))$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 4: Cryptareon-Base (NEW)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cryptareon-Base: A Practical DAG-Based PoS Protocol}
\label{sec:base}
In Section~\ref{sec:ideal} we analyzed Cryptareon-Ideal, an abstract multi-proposer DAG protocol, and showed
that it satisfies the properties (DG, DQ, DCP, TB) and thereby Persistence and Liveness. We now
move to Cryptareon-Base, a practical instantiation that relaxes the idealized assumptions to fit
a partially synchronous network and proof-of-stake setting. In particular, Cryptareon-Base uses
VRF-based eligibility, bounded short references plus an optional long reference, and explicit
transaction validity checks. Our task in this section is to demonstrate that these practical
constraints preserve the key properties, ensuring that the same soundness guarantees established
for the idealized model continue to hold in a realistic environment.

\subsection{Overview}  

\subsubsection{Assumptions and Instantiation of \ProjIdeal}
\label{subsec:base-overview}
\ProjBase is a practical instantiation of \ProjIdeal (Section~\ref{sec:ideal}) under \emph{partial synchrony} with \emph{VRF sortition}, \emph{bounded short references} (window $w$), and an \emph{optional} single long reference for connectivity. Transactions obey UTXO validity; equivocation is slashable. We retain the \emph{anchored, window-filtered} fork-choice and the \emph{CCA-local} conflict rule.

\begin{itemize}
  \item \textbf{Network.} There exists GST after which honest messages are delivered within $\Delta$ slots.
  \item \textbf{Eligibility.} Each validator $v$ is eligible in slot $s$ iff $(y,\pi)=\VRFSign_{\sk_v}(\domsep\|\chainid\|\netid\|s)$ satisfies $y<p(s,v)$ (Alg.~\ref{alg:block-creation}).
  \item \textbf{References.} In slot $s$, short references must lie in the \emph{window} $W(s;w)=[s{-}w{+}1,s]$; at most one \emph{long-ref} $\ell$ to any older block is allowed and carries zero weight.
  \item \textbf{Fork-choice.} We score tips by summing (optionally stake-weighted) short-reference counts of \emph{descendants} within the last $w$ slots, anchored at a fixed block $a$ (Alg.~\ref{alg:fork-choice}).
  \item \textbf{Conflicts.} Two incomparable blocks implying conflicting ledger states are resolved by comparing window-filtered branch weights \emph{from their} $c=\CCA(i,j)$ (Alg.~\ref{alg:cca-resolve}).
\end{itemize}

\paragraph{Parameter discipline.} Throughout the analysis we assume
\begin{equation}
\label{eq:base-params}
w \;\ge\; \Delta \;+\; \omega(\log\lambda) \qquad\text{and}\qquad 
H>\tfrac{1}{2}+\varepsilon
\end{equation}
for some constant $\varepsilon>0$. The slack $\omega(\log\lambda)$ is used for concentration bounds.

\subsubsection{Protocol Explanation (Honest Player View)}
\label{subsec:base-walkthrough}
We describe the per-slot state machine of an \emph{honest} node $P$; we explicitly indicate where Algorithms~\ref{alg:block-creation}–\ref{alg:cca-resolve} are invoked. 

%(Depending on global numbering these appear as Algorithms~6–9.)

\paragraph{Start of slot $s$.}
$P$ maintains a local DAG $G_s=(V_s,E_s)$ and a ledger state view induced by its \emph{preferred tip}. It also caches reachability summaries and a per-validator latest-block map.

\begin{enumerate}
  \item \textbf{Eligibility \& transaction sampling.}
  $P$ computes $(\mathsf{ok},\pi,y)\leftarrow\Eligibility(P,s)$. If $\mathsf{ok}=\textsf{true}$, $P$ samples a candidate transaction set $T$ from the mempool (deterministic PRF subsampling seeded by $y$) and prunes conflicts w.r.t.\ current ancestors (UTXO validity).

  \item \textbf{Reference selection (short \& long).}
  $P$ computes a \emph{deterministic} large antichain $R\subseteq V_{s,w}$ of recent blocks (e.g., \GreedyAntichain). If needed for connectivity, it chooses an \emph{optional} long-ref $\ell$ (e.g., last finalized checkpoint). By rule, $|R_{\text{out}}|\le1$ and the long-ref \emph{never} contributes weight.

  \item \textbf{Block creation and gossip (Alg.~\ref{alg:block-creation}).}
  If eligible and after validity checks, $P$ assembles
  \[
  b=\langle 
\id,\val{=}P,\slot{=}s,\txs{=}T,\refs{=}R\cup\{\ell\},y,\pi,\sigma\rangle,
  \]
  signs it, inserts it locally, and gossips.

  \item \textbf{Block reception (Alg.~\ref{alg:block-reception}, continuous during slot).}
  For each received block $b'$: verify VRF proof and signature; fetch missing parents; check (i) window constraint for short refs, (ii) at most one long-ref, (iii) no cycles, (iv) $R_w$ is an antichain in $G_{s,w}$, and (v) no UTXO conflicts vs.\ ancestors. Reject if any check fails; otherwise integrate and update summaries and $\Tips(G)$.

  \item \textbf{Anchored fork-choice (Alg.~\ref{alg:fork-choice}, end of slot).}
  With anchor $a$ (genesis or last finalized checkpoint), compute for each tip $T\in\Tips(G)$ the window-filtered score
  \[
  W(T)=\sum_{\substack{d\in\Desc^*(T)\\a\leadsto d}}\mathrm{contrib}(d)\cdot \wref(d;w),
  \]
  set preferred tip $\hat T_s\in\arg\max W(T)$ (tie-break by $(\slot,\id)$), and expose the induced ledger order.

  \item \textbf{Conflict resolution via CCA (Alg.~\ref{alg:cca-resolve}, on demand).}
  When two incomparable heads $i,j$ imply conflicting states, $P$ computes $c=\CCA(i,j)$ and compares $\BranchW(i;c,w)$ vs.\ $\BranchW(j;c,w)$. The winner determines which subtree remains eligible for inclusion in the preferred branch. This decision is \emph{consistent} with the anchored fork-choice (the preferred tip must lie on the heavier branch past the CCA).
\end{enumerate}

%\newpage

\subsection{Protocol Details}

\subsubsection{Notation and Objects}
\label{subsec:notation}
We reuse the notation from Section~\ref{sec:ideal}. In addition:
\paragraph{Ledger Validity and Conflicts.}
Let $S$ be the current ledger state. A multiset of transactions $T\subseteq \Tx$ is valid if $\Valid(S,T)=\textsf{true}$. Two transactions $x,y$ conflict (denoted $\Conflicts(x,y)$) if they cannot both appear in any valid ledger state (e.g., they double-spend a UTXO). For a set of blocks $H\subseteq V$, let $\txs(H)=\bigcup_{h\in H}\txs(h)$ be the union of their transactions. We say a set $T$ conflicts with $H$, written $\Conflicts(T,H)$, if any transaction in $T$ conflicts with any in $\txs(H)$, or any two transactions in $T$ conflict with each other.

\paragraph{Reference Window and Long-Refs.}
Fix a window parameter $w\in\mathbb{N}$. In slot $s$, the reference window is $W(s;w)=\{t: s-w+1\le t \le s\}$. Let $V_{s,w}=\{v\in V: \slot(v)\in W(s;w)\}$ and $E_{s,w}=\{(u\to v)\in E: u,v\in V_{s,w}\}$. Write $G_{s,w}=(V_{s,w},E_{s,w})$. For any block $b$ at slot $s$, partition its references as short vs. long:
\begin{equation*}
\shortrefs(b)=\{r\in\refs(b): s-\slot(r)<w\}, \qquad
\longrefs(b)=\refs(b)\setminus\shortrefs(b).
\end{equation*}
We require $|\longrefs(b)|\le1$. If there is a long-ref, call it $\longref(b)\in\Id$, and it contributes zero weight in fork-choice.

\paragraph{VRF-Based Eligibility (PoS).}
Let $(\VRFSign,\VRFVerify)$ be a secure VRF. In slot $s$, validator $v$ computes $(y,\pi)=\VRFSign(\sk(v);\ \domsep\|\Encode(\chainid)\|\Encode(\netid)\|\Encode(s))$ with $y\in[0,1)$. Let $p(s,v)$ be the per-slot success probability (typically $p(s,v)=\phi\cdot\stakefrac{v}$ for a global parameter $\phi$). Then define
\begin{equation*}
\mathsf{ok} = (y < p(s,v)),\quad \Eligibility(v,s)\text{ outputs }(\mathsf{ok},\pi,y).
\end{equation*}
On seeing a block $b$ with $(y(b),\pi(b))$, nodes verify the VRF proof $$\VRFVerify(\pk(v);\allowbreak \domsep\|\Encode(\chainid)\|\Encode(\netid)\|\Encode(\slot(b)), y(b), \pi(b))$$ and a digital signature $\VerifySig(\pk(v); b, \sigma(b))$. If either check fails, the block is ignored.

\subsubsection{Block Creation (\ProjBase)}
\begin{algorithm}[H]
\caption{Block Creation (\ProjBase)}
\label{alg:block-creation}
\begin{algorithmic}[1]
\Require Ledger state $S$, mempool $M$, validator $v$, key $\sk(v)$, stake $\stake(v)$, slot $s$, window $w$, parallelism factor $N_{\MCP}$
\Ensure New block $b$ or $\bot$ if ineligible
\State $(\mathsf{ok}, \pi, y) \gets \Eligibility(v,s)$
\If{not $\mathsf{ok}$} \Return $\bot$ \EndIf
\State $T \gets \SampleMempool(M, 1/N_{\MCP};\ \rho = \Hash(y\|s))$
\Comment{Sample transactions (e.g., subsample UTXO pool with entropy $\rho$)}
\State $R \gets \GreedyAntichain(G_{s,w})$
\Comment{Select maximal antichain of recent blocks}
\State $\ell \gets \OptionalLongRef(G, s, w, R, T)$
\Comment{Pick an optional long-ref (e.g., previous checkpoint)}
\If{$\Conflicts(T, \Anc^*(R\cup\{\ell\}\setminus\{\bot\}))$}
  \State prune a minimal subset of $T$ to remove conflicts, or \Return $\bot$
\EndIf
\State $\refs \gets 
\begin{cases}
R \cup \{\ell\} & \text{if }\ell\neq\bot,\\
R & \text{otherwise.}
\end{cases}$
%\State $b \gets \langle \id,\,\val=v,\,\slot=s,\,\txs=T,\,\refs,\,y,\,\pi,\,\sigma=\Sign(\sk(v);\id\|\val\|\slot\|\txs\|\refs\|y\|\pi)\rangle$
\State $b \gets \langle \id,\,\val,\,\slot,\,\txs,\,\refs,\,y,\,\pi,\,\sigma\rangle$ where $\val=v$, $\slot=s$, $\txs=T$, and $\sigma=\Sign(\sk(v);\id\|\val\|\slot\|\txs\|\refs\|y\|\pi)$
\State $\IntegrateAndGossip(b)$
\State \Return $b$
\end{algorithmic}
\end{algorithm}

\paragraph{Details:} $\SampleMempool(M,1/N_{\MCP};\rho)$ returns a pseudo-random subset of transactions from $M$ using seed $\rho$, to ensure verifiability. $\GreedyAntichain(G_{s,w})$ deterministically selects a large antichain in $G_{s,w}$. $\OptionalLongRef$ optionally returns a single ancestor (e.g., the last finalized block) outside the window, for connectivity. We ensure $\txs(b)$ is conflict-free with existing ancestor transactions. The new block $b$ is then integrated into the local DAG and gossiped.

\subsubsection{Block Reception and Integration}
\begin{algorithm}[H]
\caption{Block Reception (\ProjBase)}
\label{alg:block-reception}
\begin{algorithmic}[1]
\Require Incoming block $b$, local DAG $G=(V,E)$, current slot $s$
\Ensure $b$ is accepted into $G$ or deferred/rejected
\If{$b\in V$} \Return \EndIf
\If{$\exists r\in \refs(b)$ such that $r\notin V$}
  \State Request missing parent $r$; enqueue $b$; \Return
\EndIf
\State $(\mathsf{ok}',\pi',y') \gets \VRFVerify(\pk(\val(b));\ \domsep\|\Encode(\chainid)\|\Encode(\netid)\|\Encode(\slot(b)), y(b), \pi(b))$
\If{\textbf{not} $\mathsf{ok}'$ \textbf{or not} $\VerifySig(\pk(\val(b)); b, \sigma(b))$} 
  \State \textbf{reject} $b$ \Comment{VRF proof or signature invalid}
\EndIf
\If{$\exists r\in \refs(b)$ such that $\slot(b)-\slot(r) \ge w$} 
  \State \textbf{reject} $b$ \Comment{short ref outside window}
\EndIf
\If{$|\{r\in \refs(b): \slot(b)-\slot(r) \ge w\}| > 1$}
  \State \textbf{reject} $b$ \Comment{more than one long-ref used}
\EndIf
\If{$\exists r\in \refs(b)$ such that $r\in \Desc^*(b)$}
  \State \textbf{reject} $b$ \Comment{cycle detected}
\EndIf
\If{$\exists r,r'\in \refs(b),\ r\neq r'$ such that $r\nparallel r'$ in $G$}
  \State \textbf{reject} $b$ \Comment{$R_w$ not an antichain}
\EndIf
\If{$\Conflicts(\txs(b), \Anc^*(\refs(b)))$}
  \State \textbf{reject} $b$ \Comment{UTXO conflict with ancestor}
\EndIf
\State Insert $b$ and edges $(r \to b)$ for all $r\in\refs(b)$ into $G$
\State Update $\Tips(G)$, reachability summaries, and latest-block map $L$
\State $\ForkChoiceUpdate(G)$
\State $\Broadcast(b)$
\end{algorithmic}
\end{algorithm}

\begin{remark}
The integration logic assumes one-slot network delays for simplicity. In practice, a node might receive a block with $\slot(b) < s$. The checks still apply; if $s-\slot(b) < w$, the block can be integrated (it arrived late but within the window).
\end{remark}

\subsubsection{Fork Choice and Conflict Resolution (\ProjBase)}
\begin{algorithm}[H]
\caption{Anchored Fork Choice (\ProjBase)}
\label{alg:fork-choice}
\begin{algorithmic}[1]
\Require Anchor $a$, $\Tips(G)$, window $w$, stake mode $\theta\in\{\mathsf{equal},\mathsf{stake}\}$
\Ensure Preferred tip $\hat{T}$
\ForAll{$d\in V$ such that $a\leadsto d$}
  \State $\mathsf{score}(d) \gets 0$
\EndFor
\ForAll{$d\in V$ such that $a\leadsto d$}
  \State $\mathsf{score}(d) \mathrel{+}= \sum_{r\in \shortrefs(d)} \contrib(d)$
  \State $\mathsf{score}(d) \mathrel{+}= \mathsf{score}(\text{parent of }d\text{ in }G)$ \Comment{like DFS traversal or DP}
\EndFor
\State $\hat{T} \gets \arg\max_{T\in \Tips(G):\,a\leadsto T} \mathsf{score}(T)$
\State \Return $\hat{T}$
\end{algorithmic}
\end{algorithm}

\begin{remark}
We assume each validator stores or can compute $\mathsf{score}(x)$ for each $x\in V$ on its preferred branch. Practically, one can maintain $\mathsf{score}$ values incrementally as new blocks arrive.
\end{remark}

\begin{algorithm}[H]
\caption{Conflict Resolution (\ProjBase)}
\label{alg:cca-resolve}
\begin{algorithmic}[1]
\Require Conflicting blocks $i,j$ (detected UTXO conflict), window $w$
\Ensure Winner $h^*$
\State $c \gets \CCA(i,j)$
\State $W_i\gets\BranchW(i;c,w)$, \quad $W_j\gets\BranchW(j;c,w)$
\If{$W_i > W_j$} \Return $i$
\ElsIf{$W_j > W_i$} \Return $j$
\Else \Return $\min\nolimits_{\prec}\{i,j\}$ \Comment{deterministic tie-break}
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{remark}
Two conflicting transactions on different branches trigger the above resolution. The loser branch is pruned from the ledger view (though kept in the DAG for references).
\end{remark}

%\subsubsection*{Ledger Properties (Persistence and Liveness) in \ProjBase}
%We claim that under conditions~\eqref{eq:base-params}, the ledger defined by $\ForkChoiceUpdate$ and $\CCA$-based conflicts satisfies persistence and liveness. (Details follow from Section~\ref{subsec:base-security}.)


%\newpage




\paragraph{Finalization heuristic.}
$P$ may \emph{finalize} a block $B$ once it is $k$-deep under $\hat T_s$, with $k=\Theta(w)$ as derived in Theorem~\ref{thm:base-safety}. (Finalization is monotone and checkpoint-compatible.)

\subsection{Security of the Practical Protocol}
\label{subsec:base-security}
We prove the DAG properties and ledger properties for \ProjBase under~\eqref{eq:base-params}. We write $\lambda_h \triangleq \mathbb{E}[\#\text{honest eligible per slot}]=\Theta(pH|\Val|)$.

\subsubsection{Consensus properties: DG, DQ, TB, DCP}
\begin{theorem}[DAG Growth (DG) in \ProjBase]
\label{thm:base-DG}
For any interval of $\ell$ slots after GST, at least $\tau_D\ell$ honest blocks become ancestors of some honest tip by time $s{+}\ell{-}1{+}\Delta$, with probability $1-\negl(\lambda)$, for $\tau_D=\Theta(pH)$.
\end{theorem}
\begin{proof}[Proof sketch]
Post-GST, in each slot $s$ the number of honest eligible is $\mathrm{Bin}(|\Val|,p\cdot \stakefrac{\cdot})$; Chernoff concentration gives $\Omega(\lambda_h)$ honest blocks per slot over $\ell$ slots. Delivery within $\Delta$ ensures these blocks are referenced by subsequent honest blocks inside the window $w\ge \Delta$, hence they become ancestors of honest tips.
\end{proof}

\begin{theorem}[DAG Quality (DQ) in \ProjBase]
\label{thm:base-DQ}
Fix any $\ell\ge \Omega(\log\lambda)$ after GST. The fraction of honest blocks among those entering the preferred frontier during the interval is at least $\mu_D=\Theta(H)$ w.h.p.
\end{theorem}
\begin{proof}[Proof sketch]
VRF eligibility is stake-proportional; the expected honest fraction per slot is $H$. Window-filtered anchored scoring does not amplify adversarial inputs beyond the window; by linearity and concentration over $\ell$ slots the realized fraction stays within a small deviation of $H$.
\end{proof}

\begin{theorem}[Tip Boundedness (TB) in \ProjBase]
\label{thm:base-TB}
Assume $w\ge \Delta$. Then $\mathrm{TB}[\beta]$ holds with $\beta=O(\lambda_h\cdot \Delta)$ w.h.p.
\end{theorem}
\begin{proof}[Proof sketch]
Within any $\Delta$-slot horizon, honest blocks produced without mutual visibility may introduce multiple tips. After at most $\Delta$ slots these blocks are delivered and subsequent honest blocks (in slots $>s{+}\Delta$) reference \emph{all} visible recent tips within the window, merging them. Hence the tip set size is stochastically dominated by the number of honest blocks created within the last $\Delta$ slots, i.e., $O(\lambda_h\Delta)$, up to lower-order adversarial contributions that are also merged once visible.
\end{proof}

\begin{theorem}[DAG Common Past (DCP) in \ProjBase]
\label{thm:base-DCP}
There exists $k_D=\Theta(\Delta)$ such that, after removing the last $k_D$ layers under the preferred tips of any two honest parties, the remaining ancestor sets coincide w.h.p.
\end{theorem}
\begin{proof}[Proof sketch]
By TB, the honest frontier has bounded width $O(\lambda_h\Delta)$. After $\Delta$ slots, all honest blocks from earlier slots are visible to all honest parties and get cross-referenced within the window, causing the CCA between any two preferred tips to move forward monotonically. Trimming the last $\Theta(\Delta)$ layers removes the area where asynchrony can cause transient divergence, leaving an identical common past.
\end{proof}

\subsubsection{Ledger properties: Persistence and Liveness}
\begin{theorem}[Persistence (Safety) of \ProjBase]
\label{thm:base-safety}
Let $k=\Theta(w)$ be chosen so that in $w$ slots the honest branch accumulates a fixed constant margin of window-filtered weight against any competing branch past the same CCA. If a block $B$ is $k$-deep under an honest party's preferred tip at time $t$, then with probability $1-\negl(\lambda)$, $B$ remains in every honest party's ledger at all later times.
\end{theorem}
\begin{proof}[Proof sketch]
Consider a conflicting head $j$ and honest head $i$ with $c=\CCA(i,j)$. By DG, DQ, and TB, during any $w$-slot window after $c$ the honest branch contributes $\Omega(\lambda_h w)$ window-filtered references; the adversary contributes $O(\alpha |\Val| p w)$ \emph{only} to blocks \emph{actually created} within the window (withheld older references carry zero weight). Since $H>\tfrac{1}{2}{+}\varepsilon$, the honest margin in the window is positive with high probability and grows with $w$. After $k=\Theta(w)$ depth, any tie can no longer be reached by adversarial scheduling; anchored fork-choice and CCA resolution keep selecting the honest branch, preserving $B$.
\end{proof}

\begin{theorem}[Liveness of \ProjBase]
\label{thm:base-liveness}
For any valid transaction $\tx$ broadcast after GST, there exists $\ell_{\mathrm{live}}=\tilde{O}\!\left( \frac{1}{pH} + \Delta \right)$ such that $\tx$ is included in the ledger of all honest parties within $\ell_{\mathrm{live}}$ slots, except with negligible probability.
\end{theorem}
\begin{proof}[Proof sketch]
With probability $\Omega(pH)$ per slot, some honest validator is eligible and can include $\tx$. Within $\Delta$ slots, the block diffuses to all honest parties; within additional $O(w)$ slots (with $w\ge \Delta$) subsequent honest blocks reference and bury it. The anchored, window-filtered fork-choice maintains the branch as preferred (Theorem~\ref{thm:base-safety}), so $\tx$ propagates to all honest ledgers within $\tilde{O}(1/(pH)+\Delta)$.
\end{proof}

\subsubsection{Coupling to the Idealized Analysis}
\label{subsec:base-coupling}
\ProjBase is a refinement of \ProjIdeal: unbounded referencing is replaced with \emph{window-bounded} short references plus an \emph{optional} long-ref; public coins are realized with VRFs; synchrony is relaxed to partial synchrony with $w\ge \Delta$. The proofs above adapt the arguments of Section~\ref{sec:ideal} by (i) adding $\Delta$-slot delivery delays in the TB and DCP lemmas; (ii) ensuring that window-filtered weights ignore stale withheld work; and (iii) using stake-proportional VRF concentration for DQ. Thus, each ideal lemma has a practical analogue with slightly weaker (but still constant) parameters.

\subsubsection{Design Soundness: Remarks and Additional Concerns}
\label{subsec:base-remarks}
\begin{remark}[Window size vs.\ delay]
If $w<\Delta$, honest tips can \emph{expire} from the short-reference window before cross-linking, violating TB and undermining DCP and safety. Hence the constraint $w\ge \Delta$ is \emph{necessary}.
\end{remark}

\begin{remark}[Optional long-ref policy]
Long-refs guarantee global connectivity but carry zero weight. Implementations should \emph{deterministically} choose $\ell$ (e.g., last finalized checkpoint or the $\prec$-max ancestor of the smallest short-ref) to avoid adversarial steering and to enable fast parent fetching.
\end{remark}

%\begin{remark}[Slashing condition]
%If a validator is caught producing two blocks in the same slot (equivocation), a slashable event occurs. In \ProjBase, such misbehavior can be detected by comparing signatures or VRF proofs. An honest observer can include a special transaction containing $(\id(b),\id(b'),y(b),y(b'),\pi(b),\pi(b'),\sigma(b),\sigma(b'))$ in the ledger to slash $v$'s stake. This disincentivizes equivocation (except short-range attempts, which still yield no gain as they do not increase branch weight beyond the current window).
%\end{remark}

\subsubsection{Discussion of Security and Parameters}
\noindent
\textbf{Safety:} The combination of antichain reference rules, UTXO conflict checks, and the CCA-anchored fork choice ensures that once honest blocks gain a majority of in-window weight over any adversarial branch, the honest branch will prevail. The defined properties (DG/DQ/DCP/TB) hold with high probability under the usual honest majority assumptions and appropriate parameter choices, leading to persistence.

\smallskip

\noindent
\textbf{Liveness:} By allowing multiple proposers, the protocol increases the rate at which honest votes (references) are cast, helping convergence even with latency. The sliding window (with $w$ sufficiently large relative to $\Delta$) absorbs network delays. Occasional long-refs ensure the DAG does not fragment. Thus, any valid transaction will eventually be included and confirmed.

\smallskip

\noindent
\textbf{Resistance to Withholding:} Because we only count in-window references anchored at the CCA, an adversary cannot secretly build a long private branch that overtakes the honest public branch upon revelation. Withholding yields no advantage once honest blocks keep referencing the honest tips.

\smallskip

\noindent
\textbf{Parameter Choices:} A window on the order of tens of slots (e.g., $w\approx 30$) typically suffices to cover network latency for a moderate honest block rate. The parallelism factor $N_{\MCP}$ tunes how many transactions each block samples, balancing leaderless throughput with verifier load.

\subsection{Cross-Section Correspondence (Sections \ref{sec:ideal} vs \ref{sec:base})}
The following summary illustrates how the idealized protocol maps to \ProjBase:
\begin{itemize}
  \item \textbf{Eligibility:} Ideal uses implicit Bernoulli coins per slot; Base uses VRF-based eligibility (see Algorithms~\ref{alg:ideal-create}, \ref{alg:block-creation}).
  \item \textbf{Antichain selection:} Ideal selects an exact max antichain (Alg.~\ref{alg:ideal-antichain}); Base uses a greedy antichain within the window (or exact if feasible).
  \item \textbf{Long reference:} Ideal has none ($\OptionalLongRef$ always returns $\bot$); Base allows one deterministic long-ref outside the window.
  \item \textbf{Block creation:} Ideal ignores dependencies and VRFs (Alg.~\ref{alg:ideal-create}); Base includes VRF proof, UTXO conflict checks, and optional long-ref (Alg.~\ref{alg:block-creation}).
  \item \textbf{Block reception:} Ideal only checks acyclicity and parent presence (Alg.~\ref{alg:ideal-reception}); Base verifies VRF/signature, window/antichain constraints, and UTXO validity (Alg.~\ref{alg:block-reception}).
  \item \textbf{Fork choice:} Ideal uses anchored fork choice with unit weights (Alg.~\ref{alg:ideal-anchored-fc}); Base optionally stake-weights references and anchors to finalized checkpoints (Alg.~\ref{alg:fork-choice}).
  \item \textbf{Conflict resolution:} Ideal and Base use the same CCA-based rule (Alg.~\ref{alg:ideal-cca} vs \ref{alg:cca-resolve}), with Base optionally stake-weighting.
\end{itemize}


To conclude, Cryptareon-Base inherits the security guarantees of Cryptareon-Ideal: under partial
synchrony and honest majority, it satisfies DAG Growth, DAG Quality, DAG Common Past, and Tip
Boundedness, and hence achieves Persistence and Liveness. Having established these theoretical
guarantees, we now turn to empirical validation. Section~\ref{sec:impl-eval}
 presents our implementation and
simulation results, where we measure reorg distributions, tip counts, and finality times under
different network delays and adversarial stake. These experiments serve to corroborate the
analytical bounds, illustrating how the properties manifest in practice and confirming the protocol’s
robustness under realistic conditions.


\input{sec5-experiment}
\input{sec6-related}

\bibliographystyle{alpha}
\bibliography{../crypto/abbrev3,../crypto/crypto,../crypto/extra,../crypto/extra3}

\input{appendix1}

\end{document}

