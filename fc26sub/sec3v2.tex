
\section{Cryptareon-Ideal: Idealized Multi-Proposer Protocol}\label{sec:cryptareon-ideal}
\label{sec:base}
In this section, we present \emph{Cryptareon-Ideal}, an idealized multi-proposer consensus protocol. Cryptareon-Ideal allows multiple validators to propose blocks concurrently in each round, enhancing throughput and resilience against censorship. We describe the protocol’s proposer selection mechanism, fork-choice rule, and finalization logic, incorporating the reviewers’ suggestions \mnote{It might suggest that the paper was already reviewed ;)} for clarity and robustness. In particular, we introduce a \emph{preferred frontier} (a set of preferred tips) for chain selection, employ a public-coin for tie-breaking (to avoid adversary-controlled criteria), and use a public random eligibility model (dropping explicit stake fractions). All algorithms (Algorithms 1–5) are retained and updated accordingly. We also clarify the weight function used in fork choice, and we explicitly link the persistence depth $k$ to the finalization (persistence) property of the protocol.

\subsection{Protocol Model and Proposer Selection}

Cryptareon-Ideal proceeds in synchronized rounds (or time slots) indexed by $r = 1,2,\dots$. In each round, any number of validators may become block proposers. We assume a public source of randomness (a ``public coin'') produces an unpredictable random seed $\rho_r$ at the start of round $r$. This seed is used to determine proposer eligibility in a verifiable, unbiased way. Intuitively, each validator uses $\rho_r$ to perform a lottery: for example, each validator $v$ can compute a hash $y_v(r) = H(\rho_r \parallel v \parallel \text{aux})$ for some hash function $H$, and compare $y_v(r)$ to a threshold. If $y_v(r)$ falls below the threshold (which is set such that the expected number of winners per round is greater than 1), then validator $v$ is \emph{eligible} to propose a block in round $r$. This public-coin lottery mechanism does not rely on any validator’s stake fraction explicitly; stake influence can be implicitly reflected by, e.g., giving validators with more stake multiple virtual identities or adjusting their threshold, but in our idealized model we assume a uniform random selection for simplicity. The key property is that the eligibility decision is verifiable by others (because $\rho_r$ is public) and not manipulable by the adversary beyond their proportion of identities or stake. We denote by $E_r$ the set of validators eligible in round $r$ as determined by the public randomness. \mnote{We could trim this part a bit to save some, might drop lottery discussion/details.}

If a validator is eligible in round $r$ (i.e., belongs to $E_r$), it proceeds to create a new block and broadcast it to all participants. Each block includes a reference to \emph{parent} blocks from previous rounds, forming a directed acyclic graph (DAG) of blocks (which can be viewed as a ``blocktree''). In Cryptareon-Ideal, a proposer does not simply extend a single chain tip; instead, it collects all currently \emph{preferred} blocks that have no successor (tips of the block DAG) and that do not conflict, and uses them as parents for the new block. By referencing multiple parents, a block can merge concurrent proposal branches as long as they are not mutually conflicting (for example, two blocks that include conflicting transactions cannot both be parents of the same child block). This approach maximizes throughput by incorporating as many parallel proposals as possible. The set of parent pointers is included in the block header. We assume for simplicity that network propagation is reliable and reasonably fast (relative to round duration), so that all honest validators receive all blocks from round $r$ before the end of round $r+1$ (to inform their proposal in round $r+1$). We summarize the proposer’s behavior in Algorithm~\ref{alg:propose}. \mnote{We might need to trim this or the discussion below.}

\begin{algorithm}[t]
\caption{Cryptareon-Ideal: Proposer Behavior in Round $r$}\label{alg:propose}
\begin{algorithmic}[1]
\State \textbf{Input:} Public randomness $\rho_r$ for round $r$; local view of DAG (set of blocks received so far and their parent links); parameter $T$ (eligibility threshold).
\State Compute $y = H(\rho_r \parallel \text{validator\_ID} \parallel \text{aux})$.
\If {$y < T$} \Comment{Check public-coin eligibility}
    \State $\mathcal{P} \gets \Call{PreferredFrontier}{}$ \Comment{Determine current preferred frontier (parent set) from local DAG}
    \State Assemble a new block $B$ with parent pointers to all blocks in $\mathcal{P}$.
    \State Include a fresh public random label $y(B)$ in $B$ (e.g., $y(B)=H(\rho_r \parallel \text{block\_ID})$) for tie-breaking.
    \State Add pending transactions to $B$ (avoiding any that conflict with those in parents).
    \State Sign $B$ and broadcast it to all validators.
\EndIf
\end{algorithmic}
\end{algorithm}

\noindent \textbf{Discussion:} In Algorithm~\ref{alg:propose}, each eligible validator independently decides to propose a block. The function $\Call{PreferredFrontier}{}$ returns the set of current tips that the proposer will reference as parents. This set is chosen to be a \emph{preferred frontier}: a set of tip blocks that (a) are not direct ancestors of one another (each represents a different branch of the DAG), and (b) are considered the best among any conflicting choices (using the fork-choice rule defined later). In absence of conflicts, the preferred frontier can include all tips, allowing the new block to merge all concurrent proposals. If there are conflicting tips (e.g., two blocks contain a double-spend or otherwise cannot coexist in any single history), the proposer’s $\Call{PreferredFrontier}{}$ will include only one of them – specifically, the one from the branch that is deemed preferred by the fork-choice rule (weight-based, with tie-breaks resolved via the public coin label $y(\cdot)$ as described below). By including a random label $y(B)$ in the block (derived from the public coin or the block’s content in a verifiable way), the proposer ensures that any future tie in fork choice can be broken in a way that is unpredictable and not under the adversary’s control. We will detail the fork-choice and tie-breaking rules in the next subsection.

\subsection{Fork Choice: Preferred Frontier and Tie-breaking}\label{sec:fork-choice}

As blocks are produced concurrently, the block DAG may contain forks—different branches representing conflicting histories. Cryptareon-Ideal adopts a fork-choice rule that generalizes the longest-chain rule: each validator maintains a view of the block DAG and continually identifies a \emph{preferred frontier} of tips that represents the validator’s best local view of the ledger’s growth. The preferred frontier is essentially the set of tip blocks that the validator would choose to reference if it were to propose a new block (as in Algorithm~\ref{alg:propose}). We now define how this set is determined.

Each validator assigns a \emph{weight} to blocks and branches to quantify their support. In our ideal model, we define the weight of a block (or the branch ending in that block) as the total number of descendant blocks it has in the DAG (including itself). Intuitively, this is similar to ``chain length'' but generalized to the DAG: every time a new block is appended (as a child, whether single or multiple parents), it contributes weight to all of its ancestor branches. Honest validators extend only preferred branches, so heavier (more supported) branches accumulate more weight over time. By contrast, a fork that is not preferred will receive little or no extension by honest nodes and remains lighter.

Using this weight notion, our fork-choice rule is: \emph{at any point, prefer the branch (fork) that has the greatest total weight (summed over all blocks in that branch).} A validator computes the total weight for each tip in its local DAG (which corresponds to the weight of the branch ending at that tip). It then identifies the maximum weight $W_{\max}$ among those tips. All tip blocks whose branch weight is $W_{\max}$ are considered tied for heaviest. From these, the validator selects one as preferred using a deterministic but unpredictably random tie-break: specifically, each block $B$ carries a public random label $y(B)$ (as noted earlier in Algorithm~\ref{alg:propose}), drawn from a common distribution (e.g., uniform in $[0,1]$) using the public coin. The validator compares the $y(\cdot)$ labels of the candidate tip blocks. If a single tip has the highest weight, it is chosen; if multiple tips tie in weight, the tip with the largest $y(\cdot)$ value (for example) is chosen as the winner of the tie-break. Because $y(B)$ is derived from public randomness (and perhaps the block’s hash or ID), proposers cannot bias it in a way to consistently win tie-breaks. This prevents an adversary from exploiting tie-breaker rules (unlike, say, using validator IDs or hashes directly, which an adversary could influence or pre-compute).

However, importantly, we do not entirely discard the other tips that tied in weight. Instead, the \emph{preferred frontier} includes the winning tip of each conflicting fork. In practice, if two (or more) tips are conflicting (share some ancestor but diverged), only one can be extended in a single chain. The fork-choice picks one as preferred. Any other tips that are not conflicting with that chosen tip (for instance, tips on entirely separate branches that do not share a conflict) can still be included in the frontier. In other words, the preferred frontier $\mathcal{P}$ is composed of one tip from each ``incompatible fork set,'' choosing the tip that maximizes weight (and applying the $y$-label tie-break within that set if needed). By construction, all members of $\mathcal{P}$ are pairwise non-conflicting — they either lie on the same branch or on branches that forked from different parts of the history and can be later merged by a block referencing them both. This non-conflicting set of preferred tips is what an honest proposer will use as parents in its next block, as we saw in Algorithm~\ref{alg:propose}.

The above procedure can be implemented by each node in a routine that updates the preferred frontier whenever a new block is received. We provide pseudocode for the fork-choice process in Algorithm~\ref{alg:forkchoice}, which runs upon the arrival of each new block.

\begin{algorithm}[t]
\caption{Fork-Choice Update on New Block Arrival}\label{alg:forkchoice}
\begin{algorithmic}[1]
\Require New valid block $B$ is received (or locally created); local DAG $G$ (including weights).
\State Add $B$ to the DAG $G$, linking it to its parent(s). 
\State \textbf{for each} ancestor block $A$ of $B$ (including $B$ itself): increment the weight $w(A)$.
\State Remove from $\mathcal{P}$ any parent that $B$ directly extends (they are no longer tips).
\If {block $B$ does \textbf{not} conflict with the current preferred frontier $\mathcal{P}$}
    \State Add $B$ to $\mathcal{P}$ (it is a new tip).
\ElsIf {there is a conflict (i.e., $B$ is a tip on a fork that competes with an existing preferred tip $C \in \mathcal{P}$)}
    \State Compare the total weight $w_{\text{branch}}(B)$ vs $w_{\text{branch}}(C)$ of the two forked branches.
    \If {$w_{\text{branch}}(B) > w_{\text{branch}}(C)$}
        \State Replace $C$ with $B$ in $\mathcal{P}$ (branch $B$ overtakes the previous preferred branch).
    \ElsIf {$w_{\text{branch}}(B) = $ $w_{\text{branch}}(C)$}
        \If {$y(B) > y(C)$}
            \State Replace $C$ with $B$ in $\mathcal{P}$ (tie broken by public coin label $y$).
        \Else 
            \State $B$ is not added to $\mathcal{P}$ (the existing tip remains preferred).
        \EndIf
    \Else 
        \State $B$ is not added to $\mathcal{P}$ (it joins an inferior fork).
    \EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

\noindent In Algorithm~\ref{alg:forkchoice}, $\mathcal{P}$ denotes the current preferred frontier (tip set). Whenever a new block $B$ arrives, we update weights of all its ancestors and then determine how $B$ affects the tip set. If $B$ extends a tip that was already preferred, then $B$ becomes the new tip of that branch (and the old tip is no longer a tip). If $B$ extends a branch that was previously not preferred, we check if it should now be considered in the preferred set: if its branch outweighs the current preferred branch (or ties and wins the random tie-break), it will replace the competing tip in $\mathcal{P}$. If $B$ is on a fork that is still lighter, it will not be in $\mathcal{P}$ (though it remains in the DAG and could become preferred later if it gains more weight). This dynamic ensures that all validators eventually agree on a unique preferred branch through consistent tie-breaking, while still allowing non-conflicting branches to progress in parallel. \mnote{Similar here, this is more concise description of the algorithm which might be preferred over the above one if we want to trim some space.}

The use of the public-coin label $y(\cdot)$ in tie-breaking guarantees that an adversary cannot deterministically control fork outcomes when weights are equal. Since $y(\cdot)$ is unpredictable to the proposers until they actually create the block (and even then cannot be biased easily), any tie in weight is essentially broken by an unbiased random coin flip. This provides fairness and prevents a malicious proposer from exploiting the tie-break (for example, by always having a lower ID or other deterministic advantage).

\subsection{Finalization and Persistence Guarantees}

A key safety property in blockchain consensus is \emph{persistence}: once a block is sufficiently buried under newer blocks, it should remain in the history permanently (except with negligible probability). Cryptareon-Ideal achieves this by leveraging the weight-based fork-choice rule and the assumption of an honest majority of stake. Over time, honest proposers will continue building upon the preferred frontier, adding weight to the honest branch. An adversarial fork, lacking sufficient weight growth, will be unable to catch up or overtake the honest branch except with negligible probability (assuming the adversary controls less than half of the effective proposing power or stake).

We define a parameter $k$ (the \emph{persistence depth}) such that any block that is $k$ levels deep in the preferred branch is considered \emph{finalized}. In practice, this means that if a block $B$ has $k$ blocks built on top of it in the heaviest branch (i.e., its depth or ``confirmations'' count is $k$), then all honest nodes will henceforth include $B$ (and its predecessors) in their preferred frontier and will not revert it. The choice of $k$ depends on security parameters (network synchrony and adversary power); a larger $k$ gives higher confidence against reorganization. In our idealized setting, we assume $k$ is chosen so that the probability of an adversary constructing a competing branch of equal weight beyond $k$ blocks is negligible (similar to the classic analysis of $k$-confirmations in longest-chain protocols).

\subsubsection*{Linking Depth $k$ to Finalization.} To clarify the finalization logic: once a block is $k$ deep, it is irrevocably committed to the ledger. This is because by the time $k$ subsequent blocks have been added on top, the honest majority would have accrued significant weight on that branch. Even if an adversary were to have proposed some fork earlier, it would have to produce more than $k$ blocks to catch up, which is infeasible under our assumptions for appropriate $k$. Thus, all honest validators will agree that the block at depth $k$ (and all blocks below it) are part of the finalized history. In implementation terms, a node can mark a block as finalized once it sees that $k$ newer blocks extend it in its local DAG’s preferred branch. Finalized blocks can be safely considered permanent. We emphasize that the parameter $k$ ties directly into the security threshold: for example, if we assume an adversary controlling $< 50\%$ of the proposers, setting $k = \lambda \log(n)$ or a small constant (as in typical longest-chain analyses) yields an exponentially small probability of rollback (add appropriate citation). In summary, the persistence depth $k$ provides a clear rule for applications and users: after waiting for $k$ blocks, a block (and its transactions) can be treated as final.

By combining the multi-proposer, DAG-based block production with this weight-driven fork-choice and finalization rule, Cryptareon-Ideal offers both high availability (many blocks can be created in parallel) and strong consistency (eventual agreement on one history with finality after $k$ confirmations). In the next section, we will refine these ideas in a more practical setting and address additional aspects such as incentives and network conditions.
